#Cpp

ПАТТЕРНЫ.

Singleton
Фабричный метод
Асбтрактная фабрика

Константный метод - метод, не меняет данные своего класса. Ридонли методы
Class* метод(сигнатура) const (часть сигнатуры)
void Class::метод () const

delete в другом контексте.
С++11 - запретить конструктор копирования.
Нельзя будет передавать в функцию объект этого класса по значению
Logger(const Logger&) = delete;

3 потока
std::cin
поток вывода - std::cout - для вывода в терминал для юзера
поток вывода ошибок - std:cerr - для записи логов в файл

- Абстрактная фабрика
	выдает объекты

- Singleton, одиночка (! упомянуть вскользь)
	запрещает создавать более одной инстанции (объекта/экземпляра) в программе
	конструкторы класса private, удаляем конструктор копий
	статический метод self/get_instance создает статический объект класса - какбудто глобальный объект. Один экземпляр т.к. статический.
	Два метода ворнинг (меседж) и еррор (выход с кодом код 1)

- Фабричный метод
	делегирование ответственности за создание объекта в классе

Книга — Приемы объектно-ориентированного проектирования

Пораждающие паттерны
- абстрактная фабрика
- фабричный метод
- singleton
- строитель

Поведенческие паттерны (взаим-е между объектами)
- итератор
- хранитель
- Null Object
- стратегия

Структурные паттерны (как из классов и объектов создаются новые структуры)
- фасад
- мост
- декоратор
- компоновщик

Интерфейс - абстрактный класс, не имеет данных. Все методы чисто виртуальные
class IDatabase.

Юзинг:
using Fancy std::Class::NestedClass::vector();

Final
void foo() final {}
После этого указания в классе в следующих потомках его переопределений не будет 

Auto
можно не указывать тип переменной auto x = 6;

Initializer lsit
{4,5,6}; - в инитлист
include <initializer_list>
NewClass (std::initializer_list<int> list)
array = new int[list.size()]; - выделение памяти под массив

for (auto it : list)