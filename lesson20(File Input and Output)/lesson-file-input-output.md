# Работа с файлами
## **Введение**
В этой лекции мы изучим основы работы с файлами и научимся выполнять чтение и запись данных в файлы, а также освоим другие полезные операции с файловой системой.

Работа с файлами является неотъемлемой частью многих программ, и это навык, который вам пригодится в реальных проектах. Например, вы можете использовать файлы для сохранения пользовательских настроек, чтения и записи баз данных, обмена информацией между программами и многое другое.

В ходе лекции мы рассмотрим различные аспекты работы с файлами, начиная с открытия и закрытия файлов, чтения и записи данных, позиционирования в файле, обработки ошибок и исключений, а также работу с директориями и файловой системой.

У вас будет возможность увидеть практические примеры и решить задания, чтобы лучше усвоить материал. Если у вас возникнут вопросы, не стесняйтесь задавать их в ходе лекции.

Без дальнейшей задержки, давайте начнем наше погружение в мир работы с файлами в C++!

## **Открытие и закрытие файлов**

Для работы с файлами в C++ мы будем использовать потоки ввода/вывода (`ifstream`, `ofstream`, `fstream`). Эти классы предоставляют удобные методы для чтения и записи данных из/в файлы.

Для открытия файла мы используем конструкторы классов потоков ввода/вывода. Примеры:
```cpp
#include <fstream>

int main() {
    std::ifstream inputFile("input.txt");  // Открытие файла для чтения
    std::ofstream outputFile("output.txt");  // Открытие файла для записи
    std::fstream file("data.txt", std::ios::in | std::ios::out);  // Открытие файла для чтения и записи

    // Дальнейшая работа с файлами...
    
    return 0;
}
```

При открытии файла мы указываем его имя в кавычках в качестве аргумента конструктора. Кроме того, мы можем указать режим открытия файла, используя второй аргумент конструктора или метод `open()`. Режимы открытия файла могут быть следующими:

- `std::ios::in`: открытие файла для чтения.
- `std::ios::out`: открытие файла для записи. Если файл уже существует, его содержимое будет удалено. Если файл не существует, он будет создан.
- `std::ios::app`: открытие файла для добавления данных в конец файла. Если файл не существует, он будет создан.
- `std::ios::binary`: открытие файла в двоичном режиме.

Мы можем комбинировать режимы, указывая их через операцию побитового OR (`|`). Например:
```cpp
std::ofstream file("data.txt", std::ios::out | std::ios::app);  // Открытие файла для добавления данных в конец файла
```

После открытия файла мы должны проверить успешность операции, чтобы убедиться, что файл был успешно открыт. Для этого мы можем использовать метод `is_open()`:
```cpp
std::ifstream inputFile("input.txt");
if (inputFile.is_open()) {
    // Файл успешно открыт, можно выполнять операции с ним
} else {
    // Ошибка открытия файла
}
```

После завершения работы с файлом, необходимо закрыть его, чтобы освободить ресурсы. Для этого мы используем метод `close()`:
```cpp
inputFile.close();  // Закрытие файла
outputFile.close();
file.close();
```

Закрытие файла не является обязательным действием, так как файлы автоматически закрываются при уничтожении объекта потока ввода/вывода. Однако, рекомендуется явно закрывать файлы после зав
завершения работы с ними, особенно если мы открываем большое количество файлов или работаем с файлами в цикле, чтобы избежать возможных проблем.

Вот полный пример работы с открытием и закрытием файла:

```cpp
#include <fstream>

int main() {
    std::ifstream inputFile("input.txt");
    if (inputFile.is_open()) {
        // Файл успешно открыт, можно выполнять операции с ним
        // Например, читать данные из файла
        std::string line;
        while (std::getline(inputFile, line)) {
            // Обработка данных из файла
            std::cout << line << std::endl;
        }
        inputFile.close(); // Закрытие файла
    } else {
        // Ошибка открытия файла
        std::cout << "Не удалось открыть файл!" << std::endl;
    }

    return 0;
}
```

В этом примере мы открываем файл "input.txt" для чтения. После проверки успешности открытия файла, мы читаем его содержимое построчно и выводим на экран. Затем мы закрываем файл с помощью метода `close()`.

Обратите внимание, что при открытии файла для записи или добавления данных, если файл не существует, он будет создан автоматически. Если же файл уже существует, его содержимое будет удалено при открытии в режиме `std::ios::out`, а новые данные будут добавлены в конец файла при открытии в режиме `std::ios::app`.

Важно следить за корректным открытием и закрытием файлов, чтобы избежать утечки ресурсов и непредвиденного поведения программы.

Кроме использования метода `close()`, как я уже упоминал, файлы также автоматически закрываются при уничтожении объекта потока ввода/вывода. Это происходит при выходе из области видимости переменной, которая представляет собой поток.

Вот пример, который демонстрирует автоматическое закрытие файла:

```cpp
#include <fstream>

void processFile(const std::string& filename) {
    std::ifstream file(filename);
    if (file.is_open()) {
        // Обработка файла
        // Например, чтение данных из файла
        std::string line;
        while (std::getline(file, line)) {
            // Обработка данных
            std::cout << line << std::endl;
        }
        // Файл автоматически закроется при выходе из области видимости переменной file
    } else {
        std::cout << "Не удалось открыть файл: " << filename << std::endl;
    }
}

int main() {
    processFile("input.txt");
    return 0;
}
```

В этом примере функция `processFile()` открывает файл для чтения, обрабатывает его содержимое и автоматически закрывает файл при завершении функции. Таким образом, мы не вызываем метод `close()` явным образом.

Это удобно, когда мы хотим организовать логические блоки работы с файлами в функциях или блоках кода, чтобы автоматически закрывать файлы и избежать забывчивости при закрытии файлов.

Важно отметить, что если мы работаем с файлом в цикле, и каждый раз открываем и закрываем файл, это может привести к излишней нагрузке на файловую систему. В таких случаях рекомендуется открыть файл перед циклом и закрыть его после цикла, чтобы снизить количество операций открытия и закрытия файлов.

Таким образом, открытие и закрытие файлов является важной частью работы с файлами в C++. Необходимо проверять успешность открытия файла, закрывать файлы после завершения работы с ними и обратить внимание на эффективное использование открытия и закрытия файлов в циклах или функциях.

## **Чтение и запись данных в файл**
   - Чтение данных из файла: чтение посимвольно, построчно, блоками.
   - Запись данных в файл: запись посимвольно, построчно, блоками.
   - Проверка успешности операций чтения и записи.
   - Работа с текстовыми и бинарными файлами.

В C++ есть несколько способов чтения и записи данных в файл. В этом разделе мы рассмотрим чтение и запись посимвольно, построчно и блоками. Также мы обсудим проверку успешности операций чтения и записи, а также различия между текстовыми и бинарными файлами.

1. Чтение данных из файла:
   - Чтение посимвольно: Для чтения данных посимвольно мы можем использовать метод `get()` для объекта потока ввода (`ifstream`). Пример:
     ```cpp
     std::ifstream inputFile("input.txt");
     char ch;
     while (inputFile.get(ch)) {
         // Обработка символа
         std::cout << ch;
     }
     ```
   - Чтение построчно: Для чтения данных построчно мы можем использовать функцию `std::getline()`, которая позволяет считывать строку целиком. Пример:
     ```cpp
     std::ifstream inputFile("input.txt");
     std::string line;
     while (std::getline(inputFile, line)) {
         // Обработка строки
         std::cout << line << std::endl;
     }
     ```
   - Чтение блоками: Для чтения данных блоками мы можем использовать метод `read()`, который считывает заданное количество байт в указанный буфер. Пример:
     ```cpp
     std::ifstream inputFile("input.txt", std::ios::binary);
     char buffer[256];
     while (inputFile.read(buffer, sizeof(buffer))) {
         // Обработка блока данных
         // ...
     }
     ```

2. Запись данных в файл:
   - Запись посимвольно: Для записи данных посимвольно мы можем использовать метод `put()` для объекта потока вывода (`ofstream`). Пример:
     ```cpp
     std::ofstream outputFile("output.txt");
     char ch = 'A';
     outputFile.put(ch);
     ```
   - Запись построчно: Для записи данных построчно мы можем использовать оператор `<<` или метод `write()`. Пример с использованием оператора `<<`:
     ```cpp
     std::ofstream outputFile("output.txt");
     std::string line = "Hello, World!";
     outputFile << line << std::endl;
     ```
   - Запись блоками: Для записи данных блоками мы можем использовать метод `write()`, который записывает заданное количество байт из указанного буфера. Пример:
     ```cpp
     std::ofstream outputFile("output.txt", std::ios::binary);
     char buffer[256];
     // Заполнение буфера данными
     outputFile.write(buffer, sizeof(buffer));
     ```

3. Проверка успешности операций чтения и записи:
   Все методы чтения и записи данных в потоки ввода/вывода возвращают результат типа `bool`, указывающий на успешность операции. Например, метод `get()` возвращает `true`, если считывание симв
   прошло успешно, и `false`, если достигнут конец файла или произошла ошибка.

Пример проверки успешности операции чтения посимвольно:

```cpp
std::ifstream inputFile("input.txt");
char ch;
while (inputFile.get(ch)) {
    // Обработка символа
    std::cout << ch;
}

if (inputFile.eof()) {
    std::cout << "Достигнут конец файла." << std::endl;
} else if (inputFile.fail()) {
    std::cout << "Ошибка чтения файла." << std::endl;
}
```

Аналогично, методы `getline()` и `read()` также возвращают объект потока, который может быть приведен к типу `bool` для проверки успешности операции.

4. Работа с текстовыми и бинарными файлами:
   - Текстовые файлы: Текстовые файлы хранят данные в читаемом человеком виде, где символы интерпретируются как символы текста. По умолчанию, при открытии файла, потоки ввода/вывода работают в текстовом режиме. Текстовый режим обрабатывает переводы строк и другие символы в соответствии с настройками операционной системы.
   - Бинарные файлы: Бинарные файлы содержат данные в необработанном двоичном виде. При работе с бинарными файлами, не происходит никакой интерпретации символов. Вместо этого, данные считываются и записываются в файл в их исходном двоичном формате.

При открытии файла, можно указать режим, в котором файл будет открыт, с помощью флагов `std::ios::binary` и `std::ios::text`. Например:

```cpp
std::ifstream inputFile("data.bin", std::ios::binary);
```

В этом примере, файл "data.bin" будет открыт в бинарном режиме.

```cpp
std::ofstream outputFile("output.txt", std::ios::text);
```

В этом примере, файл "output.txt" будет открыт в текстовом режиме.

При работе с бинарными файлами, вы должны быть осторожны и учесть, что данные могут быть записаны в файл в двоичном формате, и их интерпретация может отличаться от текстового формата. Поэтому важно правильно читать и записывать данные в соответствии с их ожидаемым форматом.

Вот некоторые общие указания для работы с текстовыми и бинарными файлами:
- Текстовые файлы удобны для работы с читаемыми данными, такими как текстовые сообщения или структурированные данные в текстовом формате (например,форматы CSV или JSON).
- Бинарные файлы обычно используются для работы с необработанными двоичными данными, такими как изображения, аудио или видео файлы, а также для сохранения структурированных данных в компактном формате.

При работе с бинарными файлами важно учитывать порядок байт (endianness), особенности представления чисел и другие детали формата данных. Неправильное чтение или запись данных в бинарном формате может привести к непредсказуемым результатам или потере информации.

В зависимости от потребностей вашей программы, выберите подходящий режим открытия файла (текстовый или бинарный) и используйте соответствующие методы чтения и записи данных.

Рекомендуется тщательно проверять успешность операций чтения и записи, особенно при работе с файлами большого размера или в условиях ограниченных ресурсов.

В заключение, чтение и запись данных в файл являются важными аспектами работы с файлами в C++. Различные методы чтения и записи (посимвольное, построчное, блоками) предоставляют гибкость в работе с данными. Текстовые и бинарные файлы имеют свои особенности, и выбор правильного режима открытия файла зависит от типа данных и требований вашей программы. Всегда проверяйте успешность операций чтения и записи, чтобы обеспечить правильное взаимодействие с файлами.

## **Позиционирование в файле**

При работе с файлами в C++, иногда требуется перемещение текущей позиции в файле. Это может быть полезно, например, для чтения или записи данных в определенной части файла или для проверки текущей позиции.

Вот основные концепции и функции, связанные с позиционированием в файле:

1. Текущая позиция в файле:
   - При открытии файла, текущая позиция устанавливается в начало файла.
   - При чтении или записи данных, текущая позиция автоматически перемещается вперед.
   - Текущая позиция представляет собой индекс байта в файле, с которого будут производиться следующие операции чтения или записи.

2. Функции позиционирования:
   - `seekg()` и `seekp()`: Это функции для перемещения текущей позиции в файле для чтения (`seekg()`) и записи (`seekp()`). Они принимают аргументы, указывающие новую позицию, и тип смещения (относительно начала файла, конца файла или текущей позиции). Пример использования:
     ```cpp
     std::ifstream inputFile("input.txt");
     inputFile.seekg(10, std::ios::beg); // Перемещение текущей позиции на 10 байт от начала файла
     ```
   - `tellg()` и `tellp()`: Это функции, которые возвращают текущую позицию чтения (`tellg()`) и записи (`tellp()`) в файле. Они возвращают значение типа `std::streampos`, которое представляет собой тип, специфичный для потоков ввода/вывода. Пример использования:
     ```cpp
     std::ifstream inputFile("input.txt");
     std::streampos currentPosition = inputFile.tellg(); // Получение текущей позиции чтения
     ```

3. Использование позиционирования для чтения и записи данных:
   - Позиционирование позволяет считывать или записывать данные в определенных местах файла.
   - После позиционирования в нужное место, можно использовать методы чтения и записи для выполнения операций.
   - Пример чтения данных с определенной позиции:
     ```cpp
     std::ifstream inputFile("input.txt");
     inputFile.seekg(10, std::ios::beg); // Перемещение текущей позиции на 10 байт от начала файла

     std::string data;
     std::getline(inputFile, data); // Чтение строки данных из текущей позиции
     ```
   - Пример записи данных на определенную позицию:
     ```cpp
     std::ofstream outputFile("output.txt");
     outputFile.seekp(5, std::ios::beg); // Перемещение текущей позиции на 5 байт от начала файла

     std::string data = "Hello, World!";
     outputFile << data; // Запись данных на текущую позицию
     ```

Позиционирование в файле может быть полезным при работе с большими файлами или когда требуется обработать только определенную часть файла. Однако следует обратить внимание на возможные ошибки позиционирования, особенно при перемещении за пределы файла или в несуществующую позицию.

Важно также отметить, что функции позиционирования `seekg()` и `seekp()` работают с байтовыми смещениями. Если вы работаете с текстовыми файлами, то необходимо учитывать, что смещение не всегда соответствует символам, особенно если в файле есть многобайтовые символы (например, UTF-8). Для точного позиционирования в символах можно использовать функции `tellg()` и `tellp()` для получения текущей позиции и дополнительно обрабатывать кодировку символов.

В заключение, работа с позицией в файле позволяет управлять текущей позицией чтения и записи. Функции позиционирования, такие как `seekg()`, `seekp()`, `tellg()` и `tellp()`, предоставляют возможность перемещаться в файле и определять текущую позицию. Это полезно для чтения и записи данных в определенных местах файла. Однако необходимо быть внимательным при использовании позиционирования и учесть возможные ошибки, особенно при выходе за пределы файла или работе с различными кодировками символов.



## **Обработка ошибок и исключения**

При работе с файлами в C++ важно учесть возможность возникновения ошибок, таких как невозможность открытия файла, ошибки чтения или записи данных и другие. Обработка ошибок помогает предотвратить нежелательное поведение программы и обеспечить корректное выполнение операций.

Вот некоторые ключевые аспекты обработки ошибок при работе с файлами:

1. Обработка ошибок при работе с файлами:
   - При открытии файла, необходимо проверить, удалось ли успешно открыть файл. Для этого можно проверить состояние потока или указателя на файл.
   - При чтении или записи данных следует проверять успешность операций. Например, при чтении строки из файла, можно проверить, удалось ли успешно прочитать строку.
   - В случае ошибки, можно принять соответствующие меры, например, вывести сообщение об ошибке или выполнить альтернативные действия.

2. Использование исключений для обработки ошибок:
   - В C++ можно использовать механизм исключений для обработки ошибок при работе с файлами.
   - Исключения позволяют бросать и перехватывать ошибки в процессе выполнения программы.
   - При возникновении ошибки, можно бросить исключение с помощью оператора `throw`, а затем перехватить его с помощью блока `try-catch`.

3. Механизмы обработки исключений в C++:
   - В C++ исключения могут быть перехвачены с помощью блока `try-catch`. Блок `try` определяет область, в которой может возникнуть исключение, а блок `catch` определяет обработчик исключения.
   - В блоке `catch` можно указать тип исключения, который нужно перехватить. Если исключение соответствует указанному типу, будет выполнен соответствующий блок кода.
   - В случае, если исключение не было перехвачено, оно может быть передано дальше в стек вызовов.

   Вот пример использования исключений для обработки ошибок при работе с файлами:

```cpp
#include <iostream>
#include <fstream>
#include <stdexcept>

int main() {
    try {
        std::ifstream inputFile("nonexistent_file.txt");
        if (!inputFile) {
            throw std::runtime_error("Failed to open the file.");
        }

        // Чтение данных из файла...

        inputFile.close();
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return 0;
}
```

В этом примере, если не удается открыть файл, будет брошено исключение `std::runtime_error` с сообщением об ошибке. Затем, исключение перехватывается в блоке `catch`, где выводится сообщение об ошибке.

Механизм исключений в C++ позволяет более гибко и удобно обрабатывать ошибки при работе с файлами. Он позволяет отделить логику обработки ошибок от основного кода и предоставляет возможность централизованного управления и обработки исключений.

Важно отметить, что при использовании исключений необходимо обеспечить корректное освобождение ресурсов, например, закрытие файлов, в блоке `finally` или с использованием RAII (Resource Acquisition Is Initialization) принципа, используя классы и объекты, которые автоматически выполняют нужные действия при выходе из области видимости.

В заключение, при работе с файлами в C++ обработка ошибок является важной частью разработки. Это помогает предотвратить нежелательное поведение программы и обеспечить корректное выполнение операций. Использование исключений позволяет более гибко и удобно обрабатывать ошибки, разделять логику обработки ошибок от основного кода и предоставлять механизм централизованного управления исключениями.

[example work with exceptions](./code/file-exceptions.cpp)

## **Работа с директориями и файловой системой**
Работа с директориями и файловой системой (15 минут)

При работе с файлами в C++ часто возникает необходимость взаимодействия с файловой системой, такой как создание, переименование и удаление файлов, а также работа с директориями. Вот некоторые ключевые аспекты работы с директориями и файловой системой:

1. Создание, переименование и удаление файлов:
   - Для создания нового файла можно использовать функцию `std::ofstream` или `std::fstream` с указанием имени файла и режима открытия.
   - Для переименования файла можно использовать функцию `std::rename`, указав текущее имя файла и новое имя файла.
   - Для удаления файла можно использовать функцию `std::remove`, указав имя файла.
   - Примеры использования:
     ```cpp
     std::ofstream file("newfile.txt");
     if (file) {
         // Файл успешно создан
         file.close();
     }

     std::rename("oldfile.txt", "newfile.txt");

     std::remove("file.txt");
     ```

2. Работа с директориями:
   - Для создания новой директории можно использовать функцию `std::filesystem::create_directory`, указав путь к директории.
```cpp
#include <iostream>
#include <filesystem>

int main() {
    std::filesystem::path dirPath("new_directory");

    if (std::filesystem::create_directory(dirPath)) {
        std::cout << "Directory created successfully." << std::endl;
    }

    std::filesystem::current_path(dirPath);
    std::cout << "Current directory: " << std::filesystem::current_path() << std::endl;

    std::filesystem::remove(dirPath);
    std::cout << "Directory removed successfully." << std::endl;

    return 0;
}
```

В этом примере, используется пространство имен `std::filesystem` из стандартной библиотеки C++17. Функция `create_directory` создает новую директорию с указанным путем. Функция `current_path` устанавливает текущий путь к директории и возвращает текущий путь. Функция `remove` удаляет директорию с указанным путем.

3. Получение информации о файлах и директориях:
   - Для получения информации о файле или директории можно использовать функции из `std::filesystem`, такие как `exists`, `is_regular_file`, `is_directory`, `file_size` и другие.
   - Например, функция `exists` позволяет проверить, существует ли файл или директория, а функция `is_directory` определяет, является ли путь директорией.
   - Примеры использования:
     ```cpp
     std::filesystem::path filePath("file.txt");

     if (std::filesystem::exists(filePath)) {
         std::cout << "File exists." << std::endl;

         if (std::filesystem::is_regular_file(filePath)) {
             std::cout << "Regular file." << std::endl;
             std::cout << "File size: " << std::filesystem::file_size(filePath) << " bytes." << std::endl;
         }
     }
     ```

При работе с директориями и файловой системой в C++, рекомендуется использовать функции и классы из пространства имен `std::filesystem`, которое предоставляет более удобные и выразительные средства для работы с файловой системой. Этот функционал доступен начиная с C++17 и требует компилятора, который поддерживает этот стандарт.

В заключение, работа с директориями и файловой системой в C++ включает в себя операции создания, переименования и удаления файлов, работу с директориями, а также получение информации о файлах и директориях. При этом пространство имен `std::filesystem` предоставляет удобные функции и классы для выполнения этих операций.

[filedir example](./code/filedir.cpp)

## **Практические примеры и задания**

В данном разделе лекции предлагается решить задачи, связанные с работой с файлами, провести разбор примеров кода и предложить упражнения для самостоятельной работы. Вот несколько примеров и заданий, которые можно предложить учащимся:

1. Пример кода: Подсчет количества строк в текстовом файле.
   - Задача: Напишите программу, которая открывает текстовый файл и подсчитывает количество строк в нем. Выведите результат на экран.
   - Пример кода:
   [file-count-lines.cpp](./code/file-count-lines.cpp)

2. Задание: Создание простой записной книжки.
   - Напишите программу, которая позволяет пользователю создать и обновлять простую записную книжку в текстовом файле.
   - Программа должна предлагать следующие функции:
     - Создание новой записи.
     - Просмотр всех записей.
     - Поиск записи по ключевому слову.
     - Обновление или удаление записи по идентификатору.
   - Пользовательский интерфейс может быть консольным или графическим, в зависимости от вашего выбора.

3. Упражнение: Запись и чтение структуры данных в бинарный файл.
   - Создайте структуру данных, которая содержит информацию о человеке (имя, возраст, адрес и т.д.).
   - Напишите функцию, которая позволяет пользователю ввести данные о человеке и записать их в бинарный файл.
   - Напишите функцию, которая считывает данные о человеке из бинарного файла и выводит их на экран.
   - Попробуйте записать несколько структур в файл и затем прочитать их все.

Во время лекции можно провести разбор этих примеров и заданий, объяснить основные концепции и техники, используемые при работе с файлами в

## **Заключение лекции**

В данной лекции мы рассмотрели основы работы с файлами в C++. Мы изучили открытие и закрытие файлов, режимы открытия файлов, чтение и запись данных в файлы, позиционирование в файле, обработку ошибок и исключений, а также работу с директориями и файловой системой.

Работа с файлами является важной частью многих приложений, поэтому понимание основных принципов и техник работы с файлами в C++ является необходимым навыком для разработчиков.

Мы рассмотрели различные функции и методы, предоставляемые стандартной библиотекой C++, для работы с файлами, такие как потоки ввода/вывода, функции позиционирования, функции проверки успешности операций чтения и записи, а также функции для работы с директориями и файловой системой.

Мы также обратили внимание на обработку ошибок и использование исключений при работе с файлами, что позволяет более элегантно и надежно управлять ошибками и исключительными ситуациями.

В заключение, работа с файлами является важной составляющей разработки программ на C++. Она позволяет читать и записывать данные, сохранять состояние приложения и взаимодействовать с внешними ресурсами. Надеюсь, что данная лекция помогла вам лучше понять основы работы с файлами в C++ и вдохновила на дальнейшее изучение этой темы. Удачи вам в дальнейшем программировании!

**Links**
Вот несколько полезных ссылок, где вы можете найти дополнительную информацию о работе с файлами в C++:

1. Документация по стандартной библиотеке C++:
   - [std::fstream](https://en.cppreference.com/w/cpp/io/basic_fstream)
   - [std::ifstream](https://en.cppreference.com/w/cpp/io/basic_ifstream)
   - [std::ofstream](https://en.cppreference.com/w/cpp/io/basic_ofstream)
   - [std::ios](https://en.cppreference.com/w/cpp/io/ios_base)
   - [std::ios_base::openmode](https://en.cppreference.com/w/cpp/io/ios_base/openmode)

2. Руководство "File handling in C++" на GeeksforGeeks:
   - [File handling in C++](https://www.geeksforgeeks.org/file-handling-c-classes/)
   - [File Handling in C++ using ifstream & ofstream classes](https://www.geeksforgeeks.org/file-handling-c-classes/)
   - [Binary File Handling in C++](https://www.geeksforgeeks.org/binary-file-handling-c/)

3. Учебник "C++ File Input/Output" на TutorialsPoint:
   - [C++ File Input/Output](https://www.tutorialspoint.com/cplusplus/cpp_files_streams.htm)

4. Видеоуроки на YouTube:
   - [C++ Tutorial: File I/O (TheCherno)](https://www.youtube.com/watch?v=Iho2EdJgusQ)
   - [C++ File Handling Tutorial (ProgrammingKnowledge)](https://www.youtube.com/watch?v=3-wlfr_aywI)

Эти ресурсы предоставляют подробное объяснение работы с файлами в C++ и могут быть полезны для дальнейшего изучения данной темы.