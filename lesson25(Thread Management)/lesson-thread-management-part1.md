# **Часть 1: Введение в многопоточное программирование**

## Обзор понятий: процесс, поток, параллелизм, конкуренция и т.д.

Определение понятий процесса и потока
Различия между однопоточной и многопоточной моделями программирования
Параллелизм и конкуренция в контексте многопоточности
Зачем использовать многопоточность в C++

Преимущества многопоточного программирования
Улучшение производительности и отзывчивости программы
Распараллеливание задач и использование доступных ресурсов
Преимущества и ограничения многопоточного программирования

Потенциальное увеличение производительности при использовании многопоточности
Управление ресурсами и конкуренцией за них
Ограничения многопоточного программирования, такие как сложность отладки и синхронизация потоков

Процесс:
- Процесс - это экземпляр выполняющейся программы. Он содержит исполняемый код, данные и ресурсы, необходимые для работы программы. Каждый процесс имеет свою собственную область памяти.

Поток:
- Поток - это исполнительная единица внутри процесса. Он представляет собой последовательность инструкций, которые выполняются независимо от других потоков внутри процесса. Потоки внутри одного процесса разделяют общую область памяти.

Различия между однопоточной и многопоточной моделями программирования:
- Однопоточная модель программирования предполагает наличие только одного потока выполнения. Все инструкции выполняются последовательно, пошагово.
- Многопоточная модель программирования позволяет создавать и использовать несколько параллельных потоков выполнения внутри одного процесса. Каждый поток может выполнять инструкции независимо, что позволяет достичь параллелизма.

Параллелизм и конкуренция в контексте многопоточности:
- Параллелизм - это возможность выполнять несколько задач одновременно. В многопоточной модели программирования, если у вас есть несколько потоков, они могут выполняться параллельно на разных ядрах процессора или одновременно использовать ресурсы.
- Конкуренция - это ситуация, когда несколько потоков пытаются одновременно получить доступ к общим ресурсам или выполнять критические секции кода. Конкуренция может приводить к проблемам синхронизации и гонкам данных, которые необходимо управлять для корректного выполнения программы.

В многопоточной модели программирования параллелизм и конкуренция становятся важными аспектами, которые нужно учитывать при проектировании и разработке многопоточных приложений.

Зачем использовать многопоточность в C++:

Преимущества многопоточного программирования:
- Повышение производительности: Многопоточное программирование позволяет эффективно использовать ресурсы многопроцессорной системы или многоядерного процессора. Задачи могут выполняться параллельно, что приводит к более быстрому выполнению программы в целом.
- Улучшение отзывчивости: Путем использования многопоточности можно сделать программу более отзывчивой и отзывчивой на внешние события. Потоки могут обрабатывать различные задачи одновременно, что позволяет программе оставаться отзывчивой, даже если один из потоков занят длительной операцией.
- Распараллеливание задач: В некоторых случаях программы содержат задачи, которые могут быть выполнены независимо друг от друга. Многопоточное программирование позволяет распараллелить эти задачи и значительно сократить время выполнения программы.
- Использование доступных ресурсов: Многопоточность позволяет эффективно использовать доступные ресурсы, такие как CPU, память или ввод-выводные устройства. Разделение задач между потоками позволяет оптимально использовать ресурсы системы и снизить время ожидания.

Многопоточное программирование в C++ может быть особенно полезным для программ, которые требуют высокой производительности, обработки больших объемов данных, асинхронного взаимодействия с внешними системами или обработки параллельных задач. Однако, следует помнить, что многопоточное программирование также вносит сложности в области управления ресурсами, синхронизации и предотвращения проблем конкуренции данных, поэтому требуется тщательное планирование и проектирование.

Преимущества многопоточного программирования:

1. Потенциальное увеличение производительности: Многопоточное программирование может привести к увеличению общей производительности программы путем распараллеливания задач и использования доступных ресурсов процессора более эффективно. Параллельное выполнение задач может сократить время выполнения программы и повысить пропускную способность.

2. Управление ресурсами и конкуренцией за них: Многопоточное программирование позволяет эффективно управлять доступом к ресурсам, таким как память, файлы или устройства ввода-вывода. Путем правильного использования синхронизации и механизмов блокировки можно предотвратить конфликты и гонки данных, обеспечивая безопасное и согласованное взаимодействие между потоками.

Ограничения многопоточного программирования:

1. Сложность отладки: Многопоточные программы могут быть сложными для отладки и обнаружения ошибок. Когда несколько потоков выполняются параллельно, возникают новые возможности для состояний гонки и других проблем, которые могут быть сложными для воспроизведения и исправления.

2. Синхронизация потоков: Взаимодействие и синхронизация между потоками может быть сложной задачей. Необходимо правильно управлять синхронизацией доступа к разделяемым данным, чтобы избежать гонок данных и других проблем, связанных с параллельным доступом.

3. Проблемы конкуренции и гонок данных: Многопоточные программы могут столкнуться с проблемами конкуренции и гонок данных, когда несколько потоков одновременно пытаются изменить общие данные или ресурсы. Это может привести к непредсказуемому поведению программы, ошибкам и некорректным результатам, если не обеспечить правильную синхронизацию и координацию между потоками.

4. Потеря производительности из-за накладных расходов: В некоторых случаях использование многопоточности может привести к накладным расходам на создание и управление потоками, синхронизацию и коммуникацию между ними. Неправильное использование многопоточности или недостаточное распараллеливание задач может привести к тому, что накладные расходы на управление потоками превысят выгоду от параллельного выполнения.

5. Сложность программирования: Многопоточное программирование является более сложным, чем однопоточное программирование. Это требует от программиста понимания концепций синхронизации, блокировки, потокового управления и обработки возможных состояний гонки данных. Проектирование и разработка многопоточных приложений требуют дополнительных навыков и внимания к деталям.

6. Потенциальная непредсказуемость: Многопоточные программы могут быть сложными в понимании и предсказуемости. Взаимодействие между потоками и конкуренция за ресурсы может привести к непредсказуемому поведению программы, которое может быть сложно воспроизвести и исправить.

Несмотря на эти ограничения, многопоточное программирование в С++ может быть мощным инструментом для повышения производительности и улучшения отзывчивости программ. Правильное планирование, проектирование и внимание к деталям помогут избежать проблем и достичь выгод от многопоточного программирования.

# Создание и управление потоками в C++
   - Библиотека `<thread>` и класс `std::thread`
   - Создание потока с помощью функций и лямбда-выражений
   - Запуск и присоединение потоков
   - Основные операции над потоками: ожидание, завершение, проверка статуса

## Библиотека `<thread>` и класс `std::thread`
Библиотека `<thread>` и класс `std::thread` являются частью стандартной библиотеки C++ и предоставляют средства для создания и управления потоками в программе. Они позволяют разрабатывать многопоточные приложения, распараллеливать задачи и использовать вычислительные ресурсы более эффективно.

Класс `std::thread` представляет собой абстракцию потока исполнения. Он инкапсулирует поток исполнения, который может быть выполнен параллельно с главным потоком программы. Класс `std::thread` обеспечивает методы для создания, управления и синхронизации потоков.

Основные возможности класса `std::thread`:

1. Создание потока: Поток можно создать, передавая функцию или функциональный объект в конструктор класса `std::thread`. Например:

```cpp
void myFunction() {
    // Код, выполняемый в потоке
}

std::thread myThread(myFunction); // Создание потока с помощью функции
```

2. Запуск и присоединение потоков: После создания потока можно его запустить, вызвав метод `std::thread::detach()`, который отделяет поток от главного потока. При этом поток продолжает свое выполнение независимо. Чтобы дождаться завершения потока, используется метод `std::thread::join()`, который блокирует выполнение главного потока до завершения дочернего потока.

3. Операции над потоками: Класс `std::thread` предоставляет методы для ожидания выполнения потока (`std::thread::join()`), проверки его статуса (`std::thread::joinable()`), а также для получения идентификатора потока (`std::thread::get_id()`).

4. Уничтожение потока: После завершения потока или его отделения от главного потока, объект класса `std::thread` становится недействительным. Важно убедиться, что поток завершился или был отделен, перед уничтожением объекта `std::thread`.

Класс `std::thread` является основным средством для работы с потоками в C++ и предоставляет широкий набор функциональности для создания и управления параллельными задачами.


## Создание потока с помощью функций и лямбда-выражений
Потоки в C++ могут быть созданы с помощью функций и лямбда-выражений. Вот примеры создания потока с использованием обоих подходов:

1. Создание потока с помощью функции:
```cpp
#include <iostream>
#include <thread>

void myFunction() {
    // Код, выполняемый в потоке
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    std::thread myThread(myFunction); // Создание потока с помощью функции
    myThread.join(); // Дождаться завершения потока

    return 0;
}
```

2. Создание потока с помощью лямбда-выражения:
```cpp
#include <iostream>
#include <thread>

int main() {
    std::thread myThread([](){
        // Код, выполняемый в потоке
        std::cout << "Hello from thread!" << std::endl;
    });

    myThread.join(); // Дождаться завершения потока

    return 0;
}
```

В обоих случаях создается новый поток исполнения, который будет выполнять код, переданный в качестве аргумента. В первом примере это функция `myFunction()`, а во втором примере - лямбда-выражение `[](){ ... }`. Код, который будет выполняться в потоке, находится внутри фигурных скобок `{}`.

После создания потока необходимо дождаться его завершения, чтобы главный поток программы не завершился раньше дочернего потока. В примерах используется метод `std::thread::join()`, который блокирует выполнение главного потока до завершения дочернего потока.

Оба подхода - использование функций и лямбда-выражений - предоставляют гибкость при создании потоков в C++. Вы можете выбрать подход, который лучше соответствует требованиям вашей программы и удобен для вас.

## Запуск и присоединение потоков
Запуск и присоединение потоков в C++ осуществляется с использованием методов класса `std::thread`. Вот примеры запуска и присоединения потоков:

1. Запуск и присоединение потока:
```cpp
#include <iostream>
#include <thread>

void myFunction() {
    // Код, выполняемый в потоке
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    std::thread myThread(myFunction); // Создание потока с помощью функции

    // Запуск потока
    myThread.join(); // Присоединение потока

    return 0;
}
```

2. Запуск нескольких потоков и присоединение к каждому из них:
```cpp
#include <iostream>
#include <thread>

void myFunction(int id) {
    // Код, выполняемый в потоке
    std::cout << "Hello from thread " << id << "!" << std::endl;
}

int main() {
    const int numThreads = 5;
    std::thread threads[numThreads]; // Массив потоков

    // Создание и запуск потоков
    for (int i = 0; i < numThreads; ++i) {
        threads[i] = std::thread(myFunction, i); // Создание потока с помощью функции и передача идентификатора
    }

    // Присоединение к каждому потоку
    for (int i = 0; i < numThreads; ++i) {
        threads[i].join();
    }

    return 0;
}
```

В первом примере создается и запускается один поток исполнения с помощью функции `myFunction()`. Затем вызывается метод `std::thread::join()`, чтобы присоединить главный поток к созданному потоку. Это означает, что главный поток будет ожидать завершения созданного потока перед продолжением выполнения.

Во втором примере создается массив из нескольких потоков `std::thread` и запускается каждый из них в цикле. Каждому потоку передается уникальный идентификатор в качестве аргумента функции `myFunction()`. Затем в цикле происходит присоединение к каждому из созданных потоков с помощью метода `std::thread::join()`, чтобы главный поток ожидал завершения всех созданных потоков.

Присоединение потоков с помощью метода `join()` позволяет контролировать последовательность выполнения потоков и гарантировать, что главный поток не завершится до того, как все созданные потоки завершатся.

## Основные операции над потоками: ожидание, завершение, проверка статуса
Основные операции над потоками в C++ включают ожидание, завершение и проверку статуса. Для выполнения этих операций используются методы класса `std::thread`. Вот более подробное описание каждой из этих операций:

1. Ожидание выполнения потока: Метод `std::thread::join()` используется для ожидания завершения выполнения потока. Вызов этого метода блокирует выполнение текущего потока до тех пор, пока указанный поток не завершится. Например:

```cpp
#include <iostream>
#include <thread>

void myFunction() {
    // Код, выполняемый в потоке
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    std::thread myThread(myFunction); // Создание потока с помощью функции

    // Запуск потока
    myThread.join(); // Ожидание завершения потока

    std::cout << "Main thread continues..." << std::endl;

    return 0;
}
```

2. Завершение выполнения потока: Метод `std::thread::detach()` используется для отделения потока от главного потока. Вызов этого метода позволяет созданному потоку продолжать свое выполнение независимо от главного потока. Пример:

```cpp
#include <iostream>
#include <thread>

void myFunction() {
    // Код, выполняемый в потоке
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    std::thread myThread(myFunction); // Создание потока с помощью функции

    // Запуск потока
    myThread.detach(); // Отделение потока от главного потока

    std::cout << "Main thread continues..." << std::endl;

    return 0;
}
```

В этом примере вызов `std::thread::detach()` отделяет созданный поток от главного потока, и выполнение главного потока продолжается без ожидания завершения созданного потока.

3. Проверка статуса потока: Метод `std::thread::joinable()` используется для проверки, является ли поток "присоединенным" к главному потоку. Если поток присоединен, то вызов метода `joinable()` вернет значение `true`, в противном случае - `false`. Пример:

```cpp
#include <iostream>
#include <thread>

void myFunction() {
    // Код, выполняемый в потоке
    std::cout << "Hello from thread!" << std::endl;
}

int main() {
    std::thread myThread(myFunction); // Создание потока с помощью функции

    if (myThread.joinable()) {
        std::cout << "Thread is joinable." << std::endl;
    } else {
        std::cout << "Thread is not joinable." << std::endl;
    }

    myThread.join(); // Ожидание завершенияпотока

    if (myThread.joinable()) {
        std::cout << "Thread is joinable." << std::endl;
    } else {
        std::cout << "Thread is not joinable." << std::endl;
    }

    myThread.join(); // Ожидание завершения потока

    return 0;
}
```

## Синхронизация потоков
   - Проблемы конкуренции и гонки данных
   - Мьютексы (`std::mutex`) и критические секции
   - Блокировки (`std::lock_guard`, `std::unique_lock`) и RAII-идиома
   - Условные переменные (`std::condition_variable`) и сигнализация
   - Атомарные операции (`std::atomic`) и безопасное общее использование данных

Конкуренция и гонки данных являются основными проблемами, связанными с многопоточным программированием. Вот некоторые проблемы, которые могут возникнуть:

1. Гонки данных (Data Races): Гонка данных возникает, когда два или более потока одновременно обращаются к общему ресурсу (переменной, контейнеру и т.д.) и хотя бы один из них выполняет операцию записи. Это может привести к непредсказуемому поведению программы, такому как некорректные значения, неправильные результаты или даже сбои. Для решения этой проблемы необходимо использовать механизмы синхронизации, такие как мьютексы, атомарные операции или семафоры, чтобы обеспечить доступ к общим данным только одному потоку в конкретный момент времени.

2. Взаимная блокировка (Deadlock): Взаимная блокировка возникает, когда два или более потока ожидают друг друга, чтобы освободить ресурсы, которые им необходимы для продолжения выполнения. Это приводит к зацикливанию программы, где ни один из потоков не может продолжить свое выполнение. Для избежания взаимной блокировки необходимо правильно управлять порядком захвата и освобождения ресурсов, а также использовать техники, такие как иерархические блокировки или избегать блокировок вообще, если это возможно.

3. Условная гонка (Race Condition): Условная гонка возникает, когда результат выполнения программы зависит от порядка выполнения потоков или их взаимодействия, и этот порядок не определен или непредсказуем. Это может привести к некорректным результатам или ошибочным выводам. Для решения проблемы условной гонки необходимо использовать механизмы синхронизации и согласования потоков, такие как блокировки, условные переменные или атомарные операции.

4. Отсутствие прогресса (Livelock): Отсутствие прогресса возникает, когда потоки постоянно меняются и блокируются друг другом, не делая никакого реального прогресса в выполнении задачи. Это может произойти, например, при неправильном использовании блокировок или семафоров. Для избежания отсутДля избежания отсутствия прогресса (Livelock) необходимо правильно управлять блокировками и синхронизацией потоков. Важно учитывать порядок захвата блокировок и избегать ситуаций, когда потоки блокируют друг друга без возможности продолжения выполнения.

Для решения проблем конкуренции и гонок данных в многопоточных программах в C++ можно использовать следующие подходы и инструменты:

1. Использование мьютексов (std::mutex) и блокировок: Мьютексы позволяют ограничить доступ к общим данным только одному потоку в конкретный момент времени. Поток, желающий получить доступ к общим данным, должен сначала захватить мьютекс, выполнить операции и затем освободить мьютекс. Это обеспечивает взаимоисключение и предотвращает гонки данных.

2. Использование условных переменных (std::condition_variable): Условные переменные позволяют потокам ожидать определенного условия и уведомлять другие потоки, когда условие становится истинным. Это полезно для синхронизации потоков и избегания блокировок или зацикливания. Потоки могут использовать методы `wait()`, `notify_one()` и `notify_all()` для работы с условными переменными.

3. Использование атомарных операций (std::atomic): Атомарные операции обеспечивают безопасное чтение и запись общих данных из нескольких потоков без необходимости использования блокировок. Это позволяет избежать гонок данных при выполнении простых операций.

4. Использование потокобезопасных контейнеров и алгоритмов: C++ предоставляет потокобезопасные реализации контейнеров (например, `std::mutex`, `std::shared_mutex`, `std::lock_guard`) и алгоритмов (например, `std::for_each`, `std::transform`) в библиотеке `<algorithm>` и `<mutex>`. Их использование может помочь избежать проблем конкуренции и гонок данных при работе с контейнерами и выполнении операций на множестве данных.

5. Анализ и проектирование алгоритмов с учетом многопоточности: При проектировании и разработке многопоточных программ важно учитывать потенциальные проблемы конкуренции и гонок данных. Необходимо тщательно анализть алгоритмы и структуры данных, которые используются в многопоточной среде, и принимать меры для обеспечения их безопасности. Это может включать разделение данных, использование синхронизации, применение подходов lock-free или wait-free и т.д.

6. Тестирование и отладка: При разработке многопоточных программ необходимо проводить тщательное тестирование и отладку, чтобы выявить потенциальные проблемы конкуренции и гонок данных. Использование инструментов для анализа и обнаружения ошибок, таких как статический анализатор кода или инструменты трассировки потоков, может помочь выявить проблемные участки кода и обеспечить правильное взаимодействие потоков.

7. Избегание излишней конкуренции: Важно избегать излишней конкуренции и использовать многопоточность только там, где это действительно необходимо. Иногда более простые подходы, такие как асинхронное программирование или использование пула потоков, могут быть более эффективными и безопасными в конкретных сценариях.

Важно помнить, что конкуренция и гонки данных - это сложные проблемы, и правильное использование многопоточности требует глубокого понимания и аккуратного подхода. Разработчик должен быть внимателен и аккуратен при проектировании и реализации многопоточных программ, чтобы обеспечить их корректное и безопасное выполнение.

несколько примеров, демонстрирующих проблемы конкуренции и гонки данных:

1. Гонка данных (Data Race):

```cpp
#include <iostream>
#include <thread>

int counter = 0;

void incrementCounter() {
    for (int i = 0; i < 1000000; ++i) {
        counter++; // Критическая секция
    }
}

int main() {
    std::thread thread1(incrementCounter);
    std::thread thread2(incrementCounter);

    thread1.join();
    thread2.join();

    std::cout << "Counter value: " << counter << std::endl;

    return 0;
}
```

В этом примере два потока инкрементируют общую переменную `counter`. Из-за отсутствия синхронизации между потоками, возникает гонка данных, что может привести к непредсказуемому результату.

2. Взаимная блокировка (Deadlock):

```cpp
#include <iostream>
#include <mutex>
#include <thread>

std::mutex mutex1, mutex2;

void processResource1() {
    std::lock_guard<std::mutex> lock1(mutex1);
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Имитация работы
    std::lock_guard<std::mutex> lock2(mutex2);
    std::cout << "Process Resource 1" << std::endl;
}

void processResource2() {
    std::lock_guard<std::mutex> lock2(mutex2);
    std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Имитация работы
    std::lock_guard<std::mutex> lock1(mutex1);
    std::cout << "Process Resource 2" << std::endl;
}

int main() {
    std::thread thread1(processResource1);
    std::thread thread2(processResource2);

    thread1.join();
    thread2.join();

    return 0;
}
```

В этом примере два потока пытаются получить блокировку на двух мьютексах в разных порядках. Это может привести к взаимной блокировке, когда каждый поток ждет освобождения мьютекса, удерживаемого другим потоком.

3. Условная гонка (Race Condition):

```cpp
#include <iostream>
#include <thread>

int flag = 0;

void thread1Func() {
    while (flag != 1) {
    }
    std::cout << "Thread 1" << std::endl;
}

void thread2Func() {
    flag = 1;
    std::cout << "Thread 2" << std::endl;
}

int main() {
    std::thread thread1(thread1Func);
    std::thread thread2(thread2Func);

    thread1.join();
    thread2.join();

    return 0;
}
```

В этом примере два потока совместно используют переменную `flag` без синхронизации. Результат выполнения программы будет зависеть от порядка выполнения потоков, и может быть разным при каждом запуске.

несколько примеров проблем конкуренции и гонки данных:

4. Проблема "голодания" (Starvation):

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mutex;

void printNumbers(int id) {
    while (true) {
        std::lock_guard<std::mutex> lock(mutex);
        std::cout << "Thread " << id << ": ";
        for (int i = 0; i < 5; ++i) {
            std::cout << i << " ";
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
        std::cout << std::endl;
    }
}

int main() {
    std::thread thread1(printNumbers, 1);
    std::thread thread2(printNumbers, 2);

    thread1.join();
    thread2.join();

    return 0;
}
```

В этом примере два потока пытаются получить блокировку на мьютексе, чтобы выводить числа. Если один поток всегда получает доступ к мьютексу быстрее другого, возникает проблема "голодания", когда один поток постоянно получает доступ к ресурсу, тогда как другой поток остается заблокированным и не может выполнить свою работу.

5. Потенциальная утечка ресурсов:

```cpp
#include <iostream>
#include <thread>

class Resource {
public:
    Resource() {
        std::cout << "Resource acquired" << std::endl;
    }

    ~Resource() {
        std::cout << "Resource released" << std::endl;
    }
};

void processResource() {
    Resource* resource = new Resource();
    // Выполнение операций с ресурсом
    std::this_thread::sleep_for(std::chrono::seconds(1));
    delete resource; // Освобождение ресурса
}

int main() {
    std::thread thread1(processResource);
    std::thread thread2(processResource);

    thread1.join();
    thread2.join();

    return 0;
}
```

В этом примере два потока создают и используют ресурс типа `Resource`, но не освобождают его должным образом. Это может привести к потенциальной утечке ресурсов, когда ресурсы не будут освобождены и будут недоступны для других потоков.

Важно отметить, что эти примеры демонстрируют проблемы, которые могут возникнуть в многопоточных программах, и реальные сценарии использования многопоточности должны быть более тщательно разработаны и протестированы для обеспечения корректного и безопасного выполнения.

## Мьютексы (`std::mutex`) и критические секции

Мьютексы (`std::mutex`) и критические секции являются механизмами синхронизации, которые используются для обеспечения безопасного доступа к общим данным в многопоточной среде. Они позволяют предотвратить одновременный доступ нескольких потоков к общим ресурсам и защищают от проблем конкуренции и гонок данных.

Мьютексы (`std::mutex`) представляют собой примитив синхронизации, который может быть заблокирован (захвачен) одним потоком и разблокирован (освобожден) другим потоком. Когда поток хочет получить доступ к общим данным, он пытается захватить мьютекс. Если мьютекс доступен (не захвачен другим потоком), поток захватывает мьютекс и продолжает выполнение. Если мьютекс уже захвачен другим потоком, поток блокируется и ожидает, пока мьютекс не будет освобожден.

Пример использования мьютекса:

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mutex;
int sharedData = 0;

void updateSharedData() {
    std::lock_guard<std::mutex> lock(mutex); // Захват мьютекса
    sharedData++; // Обновление общих данных
}

int main() {
    std::thread thread1(updateSharedData);
    std::thread thread2(updateSharedData);

    thread1.join();
    thread2.join();

    std::cout << "Shared data: " << sharedData << std::endl;

    return 0;
}
```

В этом примере два потока вызывают функцию `updateSharedData`, которая обновляет общую переменную `sharedData`. Перед обновлением данных каждый поток захватывает мьютекс с помощью `std::lock_guard`, чтобы предотвратить одновременный доступ к `sharedData`. Таким образом, гарантируется, что обновление данных будет выполняться атомарно и безопасно.

Критическая секция - это участок кода, в котором доступ к общим данным должен быть синхронизирован с помощью мьютекса или других примитивов синхронизации. В C++, критическая секция может быть реализована с использованием мьютекса, где захват мьютекса происходит перед входом в критическую секцию, а освобождение мьютекса - после выхода из критической секции.

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mutex;
int sharedData = 0;

void updateSharedData() {
    // Вход в критическую секцию
    mutex.lock();
    sharedData++; // Обновление общих данных
    // Выход из критической секции
    mutex.unlock();
}

int main() {
    std::thread thread1(updateSharedData);
    std::thread thread2(updateSharedData);

    thread1.join();
    thread2.join();

    std::cout << "Shared data: " << sharedData << std::endl;

    return 0;
}
```

В этом примере функция `updateSharedData` содержит критическую секцию, где захват мьютекса `mutex` происходит перед обновлением общей переменной `sharedData`, а освобождение мьютекса происходит после выполнения обновления. Таким образом, гарантируется, что только один поток может одновременно выполнять обновление данных.

Важно отметить, что при использовании мьютексов и критических секций необходимо соблюдать следующие рекомендации:

1. Захватывайте мьютекс только на необходимый минимальный участок кода.
2. Избегайте длительных операций внутри критической секции, чтобы не заблокировать доступ другим потокам.
3. Обязательно освобождайте мьютекс после выполнения операций в критической секции.
4. Используйте `std::lock_guard` или `std::unique_lock` для автоматического освобождения мьютекса при выходе из области видимости.

Такие подходы позволяют обеспечить безопасность доступа к общим данным и предотвратить проблемы конкуренции и гонок данных в многопоточной среде.

## Блокировки (`std::lock_guard`, `std::unique_lock`) и RAII-идиома

Блокировки (`std::lock_guard` и `std::unique_lock`) и RAII-идиома (Resource Acquisition Is Initialization) являются важными концепциями в многопоточном программировании, используемыми для обеспечения безопасного доступа к общим ресурсам и предотвращения проблем конкуренции и гонок данных.

Блокировка (`std::lock_guard` и `std::unique_lock`) - это классы-обертки над мьютексом (`std::mutex`), которые обеспечивают автоматическое захватывание и освобождение мьютекса при использовании RAII-идиомы. Когда объект блокировки создается, он захватывает мьютекс, а при выходе из области видимости объект блокировки автоматически освобождает мьютекс.

Пример использования `std::lock_guard`:

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mutex;
int sharedData = 0;

void updateSharedData() {
    std::lock_guard<std::mutex> lock(mutex); // Захват мьютекса
    sharedData++; // Обновление общих данных
    // Мьютекс будет автоматически освобожден при выходе из области видимости lock
}

int main() {
    std::thread thread1(updateSharedData);
    std::thread thread2(updateSharedData);

    thread1.join();
    thread2.join();

    std::cout << "Shared data: " << sharedData << std::endl;

    return 0;
}
```

В этом примере объект `std::lock_guard` создается внутри функции `updateSharedData`, и при создании объекта `std::lock_guard` захватывается мьютекс. При выходе из области видимости объекта `std::lock_guard`, например, при завершении функции, мьютекс автоматически освобождается.

`std::unique_lock` предоставляет более гибкий механизм блокировки, чем `std::lock_guard`. `std::unique_lock` позволяет явно управлять моментами захвата и освобождения мьютекса, а также предоставляет дополнительные возможности, такие как отложенное захватывание и попытка захвата мьютекса.

Пример использования `std::unique_lock` с отложенным захватом:

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mutex;
int sharedData = 0;

void updateSharedData() {
    std::unique_lock<std::mutex> lock(mutex, std::defer_lock); // Отложенное захватывание мьютекса
    // Другие операции, не требующие блокировки мьютекса
    lock.lock(); // Захват мьютекса
   

 sharedData++; // Обновление общих данных
    // Мьютекс будет освобожден явно при вызове lock.unlock()
}

int main() {
    std::thread thread1(updateSharedData);
    std::thread thread2(updateSharedData);

    thread1.join();
    thread2.join();

    std::cout << "Shared data: " << sharedData << std::endl;

    return 0;
}
```

В этом примере объект `std::unique_lock` создается с флагом `std::defer_lock`, что означает, что мьютекс не будет захвачен автоматически при создании объекта `std::unique_lock`. Затем, после выполнения других операций, мьютекс захватывается явно с помощью `lock.lock()`, а затем освобождается при вызове `lock.unlock()`.

RAII-идиома (Resource Acquisition Is Initialization) предлагает использовать конструктор объекта для захвата ресурса и деструктор для его освобождения. В контексте многопоточного программирования, блокировки (`std::lock_guard` и `std::unique_lock`) применяют RAII-идиому, где захват и освобождение мьютекса происходят в конструкторе и деструкторе соответственно. Это гарантирует, что ресурс (в данном случае мьютекс) будет корректно освобожден даже при возникновении исключений или при преждевременном выходе из функции.

Использование блокировок и RAII-идиомы позволяет избежать ошибок синхронизации и обеспечить безопасность доступа к общим данным в многопоточных программах.

### Deadlock desicion
[deadlock desicion](./code/deadlock.cpp)

## Условные переменные (`std::condition_variable`) и сигнализация
Условные переменные (`std::condition_variable`) являются мощным инструментом синхронизации в многопоточном программировании. Они позволяют потокам ожидать определенного условия и осуществлять сигнализацию о его возникновении другим потокам.

Основные операции, связанные с условными переменными, включают:

1. Ожидание условия с помощью `std::condition_variable`:
   - Поток может заблокироваться и ожидать срабатывания определенного условия с помощью метода `wait()` объекта `std::condition_variable`.
   - Ожидание происходит в критической секции, где предварительно должен быть захвачен мьютекс.

2. Сигнализация о возникновении условия:
   - Когда другой поток завершает работу и хочет оповестить ожидающий поток о возникновении условия, он может вызвать метод `notify_one()` или `notify_all()` объекта `std::condition_variable`.
   - `notify_one()` пробуждает один из ожидающих потоков, а `notify_all()` пробуждает все ожидающие потоки.

Пример использования условных переменных:

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void WorkerThread()
{
    // Выполнение некоторой работы...

    std::lock_guard<std::mutex> lock(mtx);
    ready = true;
    cv.notify_one();
}

int main()
{
    std::thread worker(WorkerThread);

    // Ожидание условия
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; });

    std::cout << "Condition fulfilled. Continuing execution." << std::endl;

    worker.join();

    return 0;
}
```

В приведенном примере основной поток ожидает условия `ready`, которое будет установлено в рабочем потоке. После сигнализации о возникновении условия, основной поток продолжит свою работу.

Условные переменные являются важным инструментом для эффективного синхронизации потоков и согласования их работы в сложных сценариях. Однако важно правильно использовать условные переменные, чтобы избежать проблем, таких как преждевременное или пропущенное срабатывание условия, и добиться корректной синхронизации потоков.

Использования условных переменных (`std::condition_variable`):

1. Пример с производителем и потребителем:
```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <mutex>
#include <condition_variable>

std::queue<int> dataQueue;
std::mutex mtx;
std::condition_variable cv;

void ProducerThread()
{
    for (int i = 1; i <= 10; ++i) {
        std::this_thread::sleep_for(std::chrono::milliseconds(500));

        std::lock_guard<std::mutex> lock(mtx);
        dataQueue.push(i);
        std::cout << "Produced: " << i << std::endl;

        cv.notify_one(); // Сигнализация потребителю
    }
}

void ConsumerThread()
{
    while (true) {
        std::unique_lock<std::mutex> lock(mtx);
        cv.wait(lock, []{ return !dataQueue.empty(); });

        int data = dataQueue.front();
        dataQueue.pop();
        std::cout << "Consumed: " << data << std::endl;

        lock.unlock();
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    }
}

int main()
{
    std::thread producer(ProducerThread);
    std::thread consumer(ConsumerThread);

    producer.join();
    consumer.join();

    return 0;
}
```
В этом примере создается производитель, который помещает элементы в очередь, и потребитель, который извлекает элементы из очереди. Сигнализация о появлении элементов в очереди осуществляется с помощью условной переменной. Потребитель ожидает, пока производитель не положит элемент в очередь, а затем забирает его для обработки.

2. Пример с барьерной синхронизацией:
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;
int threadCount = 0;

void WorkerThread()
{
    std::this_thread::sleep_for(std::chrono::milliseconds(500));

    std::unique_lock<std::mutex> lock(mtx);
    ++threadCount;

    if (threadCount < 3) {
        cv.wait(lock);
    } else {
        cv.notify_all();
    }

    std::cout << "Thread " << std::this_thread::get_id() << " started" << std::endl;
}

int main()
{
    std::thread thread1(WorkerThread);
    std::thread thread2(WorkerThread);
    std::thread thread3(WorkerThread);

    thread1.join();
    thread2.join();
    thread3.join();

    std::cout << "All threads started" << std::endl;

    return 0;
}
```
В этом примере три потока ожидают, пока все они достигнут барьера, до которого можно продолжить выполнение. Каждый поток увеличивает счетчик, и если он не равен 3, поток блокируется на условной переменной. Когда все три потока достигают барьера, последний поток сигнализирует остальным потокам, и все они могут продолжить работу одновременно.

Рассмотрим более сложный жизненный пример, в котором условные переменные (`std::condition_variable`) используются для синхронизации и координации работы нескольких потоков.

Предположим, у нас есть приложение, которое моделирует банковскую очередь с несколькими кассами. В приложении могут быть следующие потоки:

1. Поток клиентов:
   - Клиенты приходят в банк и становятся в очередь.
   - Когда клиент подходит к своей очереди, он ожидает, пока освободится одна из касс.
   - Когда касса освобождается, клиент обслуживается и уходит.

2. Потоки касс:
   - Каждая касса представлена своим потоком.
   - Когда касса освобождается, она ожидает, пока в очереди появится клиент.
   - Когда клиент подходит к кассе, она обслуживает его.

3. Поток отслеживания количества клиентов:
   - Этот поток следит за количеством клиентов в очереди.
   - Если в очереди нет клиентов, он уведомляет потоки касс ожидать.

Пример кода для данной модели:

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>

std::mutex mtx;
std::condition_variable cvCustomer, cvCashier;
std::queue<int> customerQueue;
int cashierCount = 2;

void CustomerThread(int customerId)
{
    std::unique_lock<std::mutex> lock(mtx);
    customerQueue.push(customerId);
    std::cout << "Customer " << customerId << " joined the queue." << std::endl;
    cvCashier.notify_one(); // Уведомление кассира о появлении клиента

    cvCustomer.wait(lock); // Ожидание своей очереди

    std::cout << "Customer " << customerId << " is being served." << std::endl;
    std::this_thread::sleep_for(std::chrono::seconds(2));
    std::cout << "Customer " << customerId << " left." << std::endl;
}

void CashierThread()
{
    std::unique_lock<std::mutex> lock(mtx);

    while (true)
    {
        if (customerQueue.empty())
        {
            std::cout << "Cashier is waiting for a customer." << std::endl;
            cvCashier.wait(lock); // Ожидание появления клиента
        }

        if (!customerQueue.empty())
        {
            int customerId = customerQueue.front();
            customerQueue.pop();
            std::cout << "Cashier is serving customer " << customerId << "." << std::endl;

            cvCustomer.notify_one(); // Уведомление клиента о начале обслуживания

            lock.unlock();
            std::this_thread::sleep_for(std::chrono::seconds(3));
            lock.lock();

            std::cout << "Cashier finished serving customer " << customerId <<

 "." << std::endl;
        }
    }
}

void CustomerCounterThread()
{
    std::unique_lock<std::mutex> lock(mtx);

    while (true)
    {
        if (customerQueue.empty())
        {
            std::cout << "No customers in the queue. Cashiers should wait." << std::endl;
            cvCashier.notify_all(); // Уведомление кассиров ожидать
        }

        cvCustomer.wait(lock); // Ожидание клиента

        std::cout << "Number of customers in the queue: " << customerQueue.size() << std::endl;
    }
}

int main()
{
    std::thread cashier1(CashierThread);
    std::thread cashier2(CashierThread);
    std::thread customerCounter(CustomerCounterThread);

    std::vector<std::thread> customers;
    for (int i = 1; i <= 10; ++i)
    {
        customers.emplace_back(CustomerThread, i);
    }

    for (auto& customer : customers)
    {
        customer.join();
    }

    cashier1.detach();
    cashier2.detach();
    customerCounter.detach();

    return 0;
}
```

В этом примере моделируется банковская очередь с двумя кассами и десятью клиентами. Потоки клиентов добавляются в очередь, а потоки касс ожидают клиентов и обслуживают их по мере их появления. Поток отслеживания количества клиентов уведомляет потоки касс о появлении клиента и следит за количеством клиентов в очереди.

Это лишь один из возможных примеров использования условных переменных для синхронизации и координации работы нескольких потоков. Они могут быть применены в различных сценариях, где требуется согласованное взаимодействие между потоками для достижения определенных целей.

## Атомарные операции (`std::atomic`) и безопасное общее использование данных

Атомарные операции (`std::atomic`) и безопасное общее использование данных предоставляют механизмы для безопасного доступа и модификации общих данных в многопоточной среде.

Когда несколько потоков обращаются к общим данным и выполняют операции чтения и записи, возникает проблема состояния гонки. В таких случаях атомарные операции и атомарные типы данных, предоставляемые библиотекой `<atomic>`, позволяют гарантировать, что операции чтения и записи будут выполняться атомарно, то есть без промежуточных состояний, и без возникновения состояния гонки.

Пример использования атомарной переменной `std::atomic<int>`:

```cpp
#include <iostream>
#include <atomic>
#include <thread>

std::atomic<int> sharedData(0);

void incrementSharedData() {
    for (int i = 0; i < 10000; ++i) {
        sharedData++; // Атомарная операция инкремента
    }
}

int main() {
    std::thread thread1(incrementSharedData);
    std::thread thread2(incrementSharedData);

    thread1.join();
    thread2.join();

    std::cout << "Shared data: " << sharedData << std::endl;

    return 0;
}
```

В этом примере переменная `sharedData` объявлена как `std::atomic<int>`, что позволяет выполнять атомарные операции инкремента (`sharedData++`). Даже если несколько потоков одновременно выполняют инкремент, атомарные операции гарантируют корректное выполнение без возникновения состояния гонки.

Кроме атомарных операций, библиотека `<atomic>` также предоставляет другие атомарные типы данных, такие как `std::atomic_flag`, `std::atomic_bool`, `std::atomic<T>`, где `T` может быть целочисленным, указателем или пользовательским типом данных.

Помимо использования атомарных типов данных, безопасное общее использование данных в многопоточной среде также может быть достигнуто путем синхронизации доступа к общим данным с помощью мьютексов, как было описано ранее. Комбинированное использование атомарных операций и мьютексов может предоставить более гибкое и эффективное решение в зависимости от конкретных требований программы и характера общих данных.

Важно отметить, что хотя атомарные операции и атомарные типы данных обеспечивают безопасность доступа к общим данным, они не решают все проблемы синхрон

изации в многопоточной среде. В некоторых случаях может потребоваться дополнительная синхронизация или использование других средств, таких как условные переменные или флаги синхронизации, в зависимости от требований конкретной задачи.

## Высокоуровневые средства `std::future` и `std::async`
   - Асинхронное выполнение задач с `std::async`
   - Возвращение значения из асинхронной задачи с `std::future`
   - Ожидание результата и обработка исключений с `std::future`
   - Параллельное выполнение задач с `std::async` и `std::launch::async`

Высокоуровневые средства `std::future` и `std::async` предоставляют удобные инструменты для асинхронного выполнения задач и работы с результатами в C++.

1. Асинхронное выполнение задач с `std::async`:
   - Функция `std::async` позволяет запустить функцию или лямбда-выражение асинхронно, возвращая объект типа `std::future`, который представляет будущий результат выполнения задачи.
   - Пример использования `std::async`:

     ```cpp
     std::future<int> futureResult = std::async(std::launch::async, []() {
         // Код задачи
         return 42;
     });
     ```

2. Возвращение значения из асинхронной задачи с `std::future`:
   - Функция или лямбда-выражение, передаваемые в `std::async`, могут возвращать значения, которые будут доступны через объект `std::future`.
   - Пример получения значения из `std::future`:

     ```cpp
     int result = futureResult.get(); // Ожидание и получение значения
     ```

3. Ожидание результата и обработка исключений с `std::future`:
   - Метод `get()` объекта `std::future` ожидает завершение асинхронной задачи и возвращает её результат.
   - Можно также проверять статус задачи с помощью метода `wait_for()`, который позволяет ожидать задачу определенное время.
   - Пример ожидания результата с обработкой исключений:

     ```cpp
     try {
         int result = futureResult.get();
         // Обработка результата
     } catch (const std::exception& ex) {
         // Обработка исключения
     }
     ```

4. Параллельное выполнение задач с `std::async` и `std::launch::async`:
   - При использовании `std::async` можно указать политику запуска задачи с помощью флагов `std::launch::async` и `std::launch::deferred`.
   - `std::launch::async` гарантирует, что задача будет выполнена асинхронно, то есть в отдельном потоке.
   - Пример параллельного выполнения задач:

     ```cpp
     std::future<int> future1 = std::async(std::launch::async, []() {
         // Код задачи 1
         return 42;
     });

     std::future<int> future2 = std::async(std::launch::async, []() {
         // Код задачи 2
         return 100;
     });

     int result1 = future1.get();
     int result2 = future2.get();
     ```

Взаимодействие с `std::future` и `std::async` позволяет удобно организовывать асинхронное выполнение задач, получать результаты и обрабатывать исключения. Эти средства могут быть полезными при работе с параллельными алгоритмами, обработке больших объемов данных или асинхронных операциях ввода-вывода.

Следует отметить, что для более подробного изучения и примеров использования `std::future` и `std::async` рекомендуется обратиться к документации по стандартной библиотеке C++ и соответствующим учебным материалам.

В заключение первой части лекции по управлению потоками в C++, мы рассмотрели следующие основные темы:

1. Введение в многопоточное программирование:
   - Обзор понятий: процесс, поток, параллелизм, конкуренция и т.д.
   - Различия между однопоточной и многопоточной моделями программирования
   - Параллелизм и конкуренция в контексте многопоточности

2. Зачем использовать многопоточность в C++:
   - Преимущества многопоточного программирования, такие как улучшение производительности и отзывчивости программы, распараллеливание задач и использование доступных ресурсов

3. Преимущества и ограничения многопоточного программирования:
   - Потенциальное увеличение производительности при использовании многопоточности
   - Управление ресурсами и конкуренцией за них
   - Ограничения многопоточного программирования, такие как сложность отладки и синхронизация потоков

4. Создание и управление потоками в C++:
   - Библиотека `<thread>` и класс `std::thread`
   - Создание потока с помощью функций и лямбда-выражений
   - Запуск и присоединение потоков
   - Основные операции над потоками: ожидание, завершение, проверка статуса

5. Проблемы конкуренции и гонки данных:
   - Возникновение состояния гонки при одновременном доступе к общим данным из нескольких потоков
   - Необходимость синхронизации доступа к общим данным с использованием мьютексов и других средств синхронизации

6. Мьютексы (`std::mutex`) и критические секции:
   - Использование мьютексов для обеспечения взаимного исключения и безопасного доступа к общим данным

7. Блокировки (`std::lock_guard`, `std::unique_lock`) и RAII-идиома:
   - Использование блокировок для автоматического захвата и освобождения мьютекса при использовании RAII-идиомы

8. Атомарные операции (`std::atomic`) и безопасное общее использование данных:
   - Использование атомарных операций и атомарных типов данных для безопасного доступа и модификации общих данных

Рекомендуется обратиться к следующим источникам для более глубокого изучения многопоточного программирования в C++:

1. "C++ Concurrency in Action: Practical Multithreading" by Anthony Williams
2. "C++ Standard Library, The: A Tutorial and Reference" by Nicolai M. Josuttis
3. "Effective Modern C++" by Scott Meyers
4. "C++ Concurrency in Practice: Practical Multithreading" by Anthony Williams
5. Стандарт C++ (например, C++11, C++14, C++17) - официальная документация и руководства по языку C++

Кроме того, в следующей части лекции мы рассмотрим более продвинутые темы, такие как синхронизация потоков, условные переменные, фьючерсы (`std::future`) и асинхронное программирование с использованием библиотеки `<future>` и функций `std::async`.