# C++20 features

## Обзор C++20:

C++20 является последней версией языка C++ и предлагает разработчикам множество новых возможностей и улучшений. Она была разработана с учетом потребностей сообщества разработчиков C++ и внесла значительные изменения в язык, предоставляя новые инструменты и функциональность для более эффективного программирования.

Основные цели и фокусы разработки C++20:

1. Простота и улучшение разработки: C++20 стремится упростить и улучшить процесс разработки программ на C++. Это достигается с помощью внедрения новых конструкций и функций, которые позволяют разработчикам писать более понятный, компактный и безопасный код.

2. Усиление производительности: C++20 предлагает разработчикам новые возможности для оптимизации производительности и улучшения эффективности работы программ. Новые функции позволяют более эффективно управлять памятью, оптимизировать алгоритмы и сокращать время выполнения программ.

3. Поддержка современных стандартов: C++20 активно поддерживает современные стандарты разработки программного обеспечения. Это включает в себя поддержку многопоточности, параллельного программирования, работу с сетевыми протоколами и другие современные технологии.

Общие преимущества и новые возможности, доступные в C++20:

1. Модули: C++20 вводит модули, которые позволяют разработчикам организовать код в более логические и независимые единицы. Модули предоставляют лучшую изоляцию кода, сокращают время компиляции и обеспечивают более быструю сборку проекта.

2. Концепты: C++20 вводит концепты, что позволяет разработчикам задавать требования к типам, используемым в шаблонах. Концепты обеспечивают более ясное определение требуемых свойств типов и упрощают ошибки при использовании шаблонов.

3. Корутины: C++20 предлагает корутины - новый способ асинхронного программирования. Корутины позволяют писать асинхронный код в более последовательном стиле, что делает его более понятным и легким в поддержке.

4. Ranges: C++20 вводит концепцию Ranges - набора алгоритмов и типов, предназначенных для работы с коллекциями данных. Ranges предоставляют удобные и выразительные средства для манипулирования, фильтрации и трансформации данных.

5. Композиция функторов: C++20 позволяет легко компоновать функции и функторы, что упрощает их комбинирование и повторное использование.

6. Константные выражения: C++20 расширяет возможности константных выражений, позволяя использовать более сложные операции и выражения во время компиляции, что приводит к более эффективному коду и оптимизации.

Эти новые возможности C++20 предоставляют разработчикам больше средств для создания более эффективных, безопасных и легко поддерживаемых программ на C++.

# II. Введение в модули (15-20 минут)

Модули в C++20 представляют новую систему организации и разделения кода, которая заменяет традиционную систему заголовочных файлов. Модули обеспечивают более эффективную компиляцию и сборку проекта, улучшают чистоту и изоляцию кода, а также устраняют некоторые проблемы, связанные с заголовочными файлами.

1. Введение в модули:
   - Объяснение, что такое модули в контексте C++20
   - Сравнение модулей с традиционной системой заголовочных файлов
   - Описание основных целей и преимуществ использования модулей

2. Основные преимущества модулей:
   - Улучшенная производительность компиляции: модули позволяют сократить время компиляции проекта, поскольку они не требуют повторной компиляции при каждом изменении.
   - Чистота и изоляция кода: модули обеспечивают лучшую изоляцию кода, предотвращая конфликты имен и нежелательные зависимости.
   - Лучшая поддержка инкапсуляции: модули предоставляют возможность скрыть внутренние детали реализации, что способствует лучшей инкапсуляции и сокрытию информации.

3. Синтаксис и использование модулей в C++20:
   - Обзор синтаксиса объявления и импорта модулей
   - Показ примера простого модуля и его использования в программе
   - Рассмотрение возможностей и синтаксиса экспорта символов из модуля
   - Объяснение механизма разрешения имен в модулях

4. Практические рекомендации и подходы к использованию модулей:
   - Рекомендации по организации кода в модулях и выбору структуры модулей
   - Подходы к модуляризации существующего кода и интеграции модулей в проекты
   - Рассмотрение возможностей использования модулей в больших проектах и библиотеках

5. Совместимость с предыдущими версиями C++:
   - Обсуждение вопросов совместимости модулей с кодом, написанным для более ранних версий C++
   - Рассмотрение подходов к постепенной миграции с использованием модулей в существующих проекта

Когда речь идет о модулях C++20 и их использовании с помощью CMake, следующий пример может быть полезен.

1. Создайте файл CMakeLists.txt в корневом каталоге проекта:

```cmake
cmake_minimum_required(VERSION 3.21)
project(MyProject)

set(CMAKE_CXX_STANDARD 20)

# Добавьте команду use_module для использования модулей
function(use_module target module_name)
    target_compile_features(${target} PRIVATE cxx_std_20)
    target_compile_options(${target} PRIVATE "-fmodules-ts")
    target_link_options(${target} PRIVATE "-fmodules-ts")
    target_sources(${target} PRIVATE ${module_name}.cpp)
endfunction()

# Создайте исполняемый файл и вызовите use_module для каждого модуля
add_executable(MyExecutable main.cpp)
use_module(MyExecutable MyModule)
```

2. Создайте файл main.cpp с точкой входа в программу:

```cpp
import MyModule;

int main()
{
    MyModule::hello();
    return 0;
}
```

3. Создайте файл MyModule.cpp с определением модуля:

```cpp
module;

export module MyModule;

export void hello()
{
    // Код функции
}
```

В этом примере мы создаем проект CMake, устанавливаем стандарт C++20 и используем функцию `use_module` для добавления модуля `MyModule` к цели `MyExecutable`. Затем в `main.cpp` мы импортируем `MyModule` и вызываем функцию `hello()`, которая определена в модуле `MyModule`. В файле `MyModule.cpp` мы определяем сам модуль `MyModule` с использованием ключевого слова `export module` и экспортируем функцию `hello()`.

Обратите внимание, что пример основан на предположении, что ваш компилятор C++ поддерживает модули C++20. Команды и флаги компилятора могут отличаться в зависимости от используемого компилятора и операционной системы.

II. Практические рекомендации и подходы к использованию модулей

1. Рекомендации по организации кода в модулях и выбору структуры модулей:
   - Разделение кода на модули должно быть основано на логической структуре проекта. Разделите код на модули по функциональности или по компонентам.
   - Стремитесь к созданию независимых модулей, которые можно компилировать и использовать отдельно без необходимости включать все модули проекта.
   - Минимизируйте зависимости между модулями, чтобы улучшить изоляцию и возможности повторного использования.

2. Подходы к модуляризации существующего кода и интеграции модулей в проекты:
   - Начните с модуляризации наиболее независимых частей вашего кода. Это позволит вам оценить преимущества модулей и протестировать процесс модуляризации.
   - Используйте инкрементальный подход, постепенно модуляризируя остальные части кода.
   - Обратите внимание на зависимости и взаимосвязи между модулями. Установите четкие интерфейсы и уровни абстракции для упрощения интеграции модулей.

3. Возможности использования модулей в больших проектах и библиотеках:
   - Модули позволяют улучшить время компиляции больших проектов путем уменьшения объема перекомпиляции.
   - Модули обеспечивают лучшую изоляцию кода, что способствует уменьшению возможных конфликтов имен и улучшению структуры проекта.
   - Модули могут быть использованы для создания модульных библиотек, которые могут быть легко интегрированы в другие проекты.

Это лишь общие рекомендации и подходы к использованию модулей в C++20. Фактический подход может варьироваться в зависимости от специфики проекта и его требований.

# III. Концепты

1. Введение в концепты:
   - Концепты являются новой функциональностью в C++20, которая позволяет определять требования к типам в шаблонах.
   - Концепты позволяют задавать условия и ограничения для параметров шаблона, чтобы обеспечить корректность типов, используемых в шаблонах.

2. Применение концептов в шаблонах:
   - Концепты могут быть применены к параметрам шаблона с помощью ключевого слова `requires`, за которым следует выражение, определяющее требования.
   - Концепты могут использоваться для проверки наличия определенных операций, типов данных, свойств и т.д., необходимых для корректной работы шаблона.
   - Компилятор проверяет соответствие типов параметров шаблона заданным концептам во время компиляции и выдает ошибку, если требования не выполняются.

3. Различные примеры использования концептов:
   - Концепты могут быть использованы для проверки, является ли тип итератором, числом, контейнером и т.д.
   - Можно создавать собственные концепты, определяя условия и требования, которые должны быть выполнены типами параметров шаблона.
   - Концепты также могут быть использованы вместе с различными алгоритмами, чтобы задать ограничения на типы данных, с которыми алгоритм может работать.

Примеры использования концептов:
```cpp
template <typename T>
concept Integral = std::is_integral<T>::value;

template <typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::convertible_to<T>;
};

template <typename T>
requires Integral<T> && Addable<T>
T add(T a, T b)
{
    return a + b;
}

int main()
{
    int result = add(2, 3);
    return 0;
}
```

В этом примере определены два концепта: `Integral`, который проверяет, является ли тип целочисленным, и `Addable`, который проверяет, можно ли выполнить операцию сложения для данного типа. Функция `add` использует эти концепты для ограничения типов, которые могут быть переданы ей.

## III. Введение в концепты

1. Что такое концепты:
   - Концепты являются новой функциональностью, представленной в стандарте C++20, которая позволяет определять требования к типам в шаблонах.
   - Концепты позволяют задавать условия и ограничения для параметров шаблона, чтобы обеспечить корректность типов, используемых в шаблонах.

2. Зачем нужны концепты:
   - Концепты предоставляют более строгую проверку типов в шаблонах, чем просто использование `static_assert` или специализации шаблонов.
   - Они позволяют программисту задать явные требования к типам, которые должны быть удовлетворены, чтобы шаблон мог быть использован.
   - Концепты помогают улучшить понимание и читаемость кода, позволяя явно указывать требования к типам, которые должны быть удовлетворены.

3. Как использовать концепты:
   - Концепты определяются с помощью ключевого слова `concept`.
   - В шаблоне можно использовать концепт для требования определенных свойств или операций у типов параметров.
   - Концепт может быть применен к параметру шаблона с использованием ключевого слова `requires`, за которым следует выражение, определяющее требования.
   - Если переданный аргумент шаблона не удовлетворяет заданным концептам, компилятор выдаст ошибку.

Пример использования концептов:
```cpp
template <typename T>
concept Incrementable = requires(T a) {
    { ++a } -> std::same_as<T&>;
};

template <Incrementable T>
T increment(T value)
{
    return ++value;
}

int main()
{
    int x = 5;
    int result = increment(x);  // Валидное использование, тип int удовлетворяет концепту Incrementable
    double y = 3.14;
    double result2 = increment(y);  // Ошибка компиляции, тип double не удовлетворяет концепту Incrementable
    return 0;
}
```

В этом примере определен концепт `Incrementable`, который требует наличия операции инкремента `++` с возвращаемым значением типа `T&`. Функция `increment` принимает аргумент, удовлетворяющий концепту `Incrementable`, и выполняет инкремент этого аргумента.

## Применение концептов в шаблонах:

1. Ключевое слово `requires`:
   - Для применения концептов к параметрам шаблона используется ключевое слово `requires`.
   - Ключевое слово `requires` указывает на необходимость выполнения определенных требований для параметров шаблона.

2. Определение требований с помощью выражений:
   - За ключевым словом `requires` следует выражение, определяющее требования, которые должны быть выполнены.
   - Выражение может содержать различные проверки наличия определенных операций, типов данных, свойств и других требований, необходимых для корректной работы шаблона.

3. Проверка соответствия типов во время компиляции:
   - Компилятор проверяет соответствие типов параметров шаблона заданным концептам во время компиляции.
   - Если переданный аргумент шаблона не удовлетворяет требованиям, определенным концептом, компилятор выдаст ошибку компиляции.

Пример использования концептов в шаблонах:
```cpp
template <typename T>
concept Printable = requires(T value) {
    { std::cout << value } -> std::same_as<std::ostream&>;
};

template <typename T>
void print(T value)
requires Printable<T>
{
    std::cout << value << std::endl;
}

int main()
{
    int x = 5;
    print(x);  // Валидное использование, тип int удовлетворяет концепту Printable
    std::string str = "Hello";
    print(str);  // Валидное использование, тип std::string удовлетворяет концепту Printable
    std::vector<int> vec = {1, 2, 3};
    print(vec);  // Ошибка компиляции, тип std::vector<int> не удовлетворяет концепту Printable
    return 0;
}
```

В этом примере определен концепт `Printable`, который требует, чтобы значение типа `T` могло быть выведено в стандартный поток вывода `std::cout` с помощью оператора `<<`, возвращая `std::ostream&`. Функция `print` принимает аргумент, удовлетворяющий концепту `Printable`, и выводит его значение в стандартный поток вывода.

# IV. Корутины

1. Введение в корутины:
   - Корутины являются новой функциональностью, представленной в стандарте C++20, которая позволяет создавать функции с необычным поведением выполнения.
   - Корутины предоставляют возможность создания сопрограмм - функций, которые могут быть приостановлены и возобновлены в произвольные моменты времени.
   - Они предоставляют удобный способ для написания асинхронного кода и обработки событий.

2. Синтаксис и основные понятия корутин:
   - Корутины объявляются с использованием ключевого слова `co_await` и возвращаются с использованием ключевого слова `co_return`.
   - Ключевое слово `co_yield` позволяет приостановить выполнение корутины и вернуть значение, которое может быть получено вызывающей стороной.
   - Корутины могут быть асинхронными или генераторами, в зависимости от того, используется ли `co_await` или `co_yield`.
   - Корутины могут иметь состояние, которое сохраняется между вызовами и позволяет продолжить выполнение с сохраненного состояния.

3. Применение корутин в асинхронном программировании:
   - Корутины предоставляют удобный способ для написания асинхронного кода без использования колбэков или сложных конструкций.
   - Асинхронные корутины могут быть использованы для работы с различными операциями ввода-вывода, сетевыми запросами и другими асинхронными задачами.
   - Корутины позволяют писать асинхронный код в стиле последовательных операций, что делает его более понятным и поддерживаемым.

Пример использования корутин для асинхронного программирования:
```cpp
#include <iostream>
#include <experimental/coroutine>

std::experimental::coroutine_handle<> coroHandle;

struct Task {
    struct promise_type {
        auto get_return_object() { return Task{}; }
        auto initial_suspend() { return std::experimental::suspend_never{}; }
        auto final_suspend() noexcept { return std::experimental::suspend_always{}; }
        void return_void() {}
        void unhandled_exception() {}
    };

    using coro_handle = std::experimental::coroutine_handle<promise_type>;
    coro_handle handle;

    explicit Task(coro_handle h) : handle(h) {}
    ~Task() { if (handle) handle.destroy(); }
};

Task foo() {
    std::cout << "Start" << std::endl;
    co_await std::experimental::suspend_always{};
    std::cout << "Resume" << std::endl;
}

int main() {
    foo();
    coroHandle.resume();
    std::cout << "End" << std::endl;
    return 0;
}
```

В этом примере определена корутина `foo()`, которая выводит сообщение "Start", приостанавливает свое выполнение с помощью `co_await`, а затем выводит сообщение "Resume". В функции `main()` корутина вызывается с помощью `foo()`, а затем ее выполнение возобновляется с помощью `coroHandle.resume()`. Результатом выполнения программы будет вывод следующих сообщений:
```
Start
Resume
End
```

К сожалению, в текущей версии моего модели я не могу предоставить прямой доступ к конкретной версии компилятора или подробной конфигурации CMake. Однако, я могу привести общие примеры использования корутин без сторонних библиотек в C++20, и вы можете адаптировать их под вашу конкретную среду разработки и компилятор.

Пример 1: Простой пример использования корутин для асинхронного чтения файла:
```cpp
#include <fstream>
#include <iostream>
#include <experimental/coroutine>

std::experimental::coroutine_handle<> coroHandle;

struct FileReadAwaitable {
    std::ifstream file;
    std::string buffer;

    FileReadAwaitable(const std::string& filename) : file(filename) {}

    bool await_ready() const {
        return !file;
    }

    void await_suspend(std::experimental::coroutine_handle<> handle) {
        coroHandle = handle;
    }

    std::string await_resume() {
        return buffer;
    }
};

FileReadAwaitable asyncReadFile(const std::string& filename) {
    std::ifstream file(filename);
    std::string buffer;

    if (file) {
        file.seekg(0, std::ios::end);
        buffer.resize(file.tellg());
        file.seekg(0, std::ios::beg);
        file.read(&buffer[0], buffer.size());
    }

    co_return buffer;
}

int main() {
    auto task = asyncReadFile("example.txt");

    if (!task.await_ready()) {
        task.await_suspend(coroHandle);
    }

    std::string result = task.await_resume();
    std::cout << "File content: " << result << std::endl;

    return 0;
}
```

Пример 2: Применение корутин для реализации бесконечной генерации последовательности чисел Фибоначчи:
```cpp
#include <iostream>
#include <experimental/coroutine>

std::experimental::coroutine_handle<> coroHandle;

struct FibonacciGenerator {
    int current = 0;
    int next = 1;

    bool await_ready() const {
        return false;
    }

    void await_suspend(std::experimental::coroutine_handle<> handle) {
        coroHandle = handle;
    }

    int await_resume() {
        int result = current;
        int temp = current + next;
        current = next;
        next = temp;
        return result;
    }
};

FibonacciGenerator generateFibonacciSequence() {
    while (true) {
        co_yield co_await FibonacciGenerator{};
    }
}

int main() {
    auto generator = generateFibonacciSequence();

    for (int i = 0; i < 10; ++i) {
        if (!generator.await_ready()) {
            generator.await_suspend(coroHandle);
        }

        int value = generator.await_resume();
        std::cout << value << " ";
    }

    std::cout << std::endl;

    return 0;
}
```

Обратите внимание, что эти примеры предполагают, что ваш компилятор поддерживает корутины и C++20. Для компиляции кода с использованием корутин вам может потребоваться определить соответствующие флаги компилятора в вашем CMake-файле конфигурации.

