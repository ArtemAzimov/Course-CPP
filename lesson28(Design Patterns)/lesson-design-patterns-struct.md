# Введение в поведенческие паттерны

Добро пожаловать на лекцию о поведенческих паттернах в программировании. В ходе этой лекции мы рассмотрим различные поведенческие паттерны и их применение в языке программирования C++.

Перед тем, как перейти к поведенческим паттернам, давайте сделаем краткий обзор дизайн-паттернов в программировании. Дизайн-паттерны представляют собой bewrw (best practices) или bewrw (bewst solutions) для определенных проблем, возникающих в процессе разработки программного обеспечения. Они являются проверенными подходами к решению этих проблем и предлагают гибкую и эффективную архитектуру программ.

Теперь давайте перейдем к понятию поведенческих паттернов. Поведенческие паттерны описывают способы взаимодействия объектов и управления поведением программы. Они фокусируются на взаимодействии между объектами, делая программу более гибкой и расширяемой.

Зачем же использовать поведенческие паттерны в разработке? Они предлагают следующие преимущества:

1. Улучшение расширяемости: Поведенческие паттерны позволяют легко добавлять новое поведение в программу без изменения существующего кода. Это делает программу более гибкой и легкой в поддержке.

2. Разделение ответственностей: Паттерны помогают разделить ответственности между объектами, что улучшает модульность и облегчает сопровождение кода.

3. Упрощение кода: Поведенческие паттерны предлагают стандарные решения для часто встречающихся проблем, что позволяет упростить код и сделать его более понятным и поддерживаемым.

4. Облегчение тестирования: Использование паттернов помогает создавать более тестируемый код, так как каждая часть программы выполняет четко определенную функцию и может быть протестирована отдельно.

В заключение, поведенческие паттерны являются мощным инструментом для проектирования гибких, расширяемых и понятных программ. В следующей части лекции мы рассмотрим конкретные поведенческие паттерны и их примеры использования в C++.


# Паттерн "Наблюдатель"

Описание паттерна:
Паттерн "Наблюдатель" позволяет определить зависимость "один-ко-многим" между объектами таким образом, чтобы при изменении состояния одного объекта все зависимые от него объекты автоматически уведомлялись и обновлялись. В этом паттерне есть два основных участника: субъект (также называемый издателем) и наблюдатели (подписчики). Субъект содержит состояние, которое подлежит изменению, а наблюдатели регистрируются для получения уведомлений об изменении состояния и выполняют соответствующие действия.

Примеры использования в C++:
Паттерн "Наблюдатель" широко применяется в ситуациях, когда необходимо обеспечить слабую связанность между объектами и уведомлять один объект о изменениях в другом. Некоторые примеры использования паттерна "Наблюдатель" в C++ включают:

1. Графический интерфейс пользователя: В приложениях с графическим интерфейсом пользователя (GUI) паттерн "Наблюдатель" используется для реализации механизма обновления виджетов или компонентов интерфейса при изменении данных или состояния.

2. Сетевые соединения: В сетевых приложениях паттерн "Наблюдатель" может использоваться для уведомления объектов о приходе новых данных по сети или изменении состояния соединения.

3. Событийная модель: Паттерн "Наблюдатель" также широко применяется в событийных моделях, где объекты могут быть зарегистрированы для получения уведомлений о различных событиях и реагировать на них соответствующим образом.

Реализация паттерна "Наблюдатель":
В C++ паттерн "Наблюдатель" может быть реализован с использованием набора классов и интерфейсов. Основные компоненты реализации включают:

1. Интерфейс Subject (Субъект): Определяет методы для регистрации, удаления и уведомления наблюдателей.

2. Класс ConcreteSubject (Конкретный субъект): Реализует интерфейс Subject и содержит состояние, которое может изменяться. При изменении состояния уведомляет зарегистрированных наблюдателей.

3. Интерфейс Observer (Наблюдатель): Определяет метод обновления, который вызывается при получении уведомления о изменении состояния субъекта.

4. Классы ConcreteObserver (Конкретные наблюдатели): Реализуют интерфейс Observer и определяют свою логику обновления при изменении состояния субъекта.

Реализация паттерна "Наблюдатель" может варьироваться в зависимости от конкретных требований и контекста приложения.

## Конкретная реализация паттерна "Наблюдатель" может выглядеть следующим образом:

```cpp
#include <iostream>
#include <vector>

// Интерфейс Observer
class Observer {
public:
    virtual void update() = 0;
};

// Класс ConcreteObserverA
class ConcreteObserverA : public Observer {
public:
    void update() override {
        std::cout << "ConcreteObserverA: Received notification.\n";
    }
};

// Класс ConcreteObserverB
class ConcreteObserverB : public Observer {
public:
    void update() override {
        std::cout << "ConcreteObserverB: Received notification.\n";
    }
};

// Интерфейс Subject
class Subject {
private:
    std::vector<Observer*> observers;

public:
    void attach(Observer* observer) {
        observers.push_back(observer);
    }

    void detach(Observer* observer) {
        auto it = std::find(observers.begin(), observers.end(), observer);
        if (it != observers.end()) {
            observers.erase(it);
        }
    }

    void notify() {
        for (Observer* observer : observers) {
            observer->update();
        }
    }
};

int main() {
    // Создание субъекта
    Subject subject;

    // Создание наблюдателей
    ConcreteObserverA observerA;
    ConcreteObserverB observerB;

    // Регистрация наблюдателей
    subject.attach(&observerA);
    subject.attach(&observerB);

    // Уведомление наблюдателей
    subject.notify();

    // Открепление одного наблюдателя
    subject.detach(&observerA);

    // Уведомление оставшегося наблюдателя
    subject.notify();

    return 0;
}
```

В данном примере мы создаем классы `ConcreteObserverA` и `ConcreteObserverB`, которые реализуют интерфейс `Observer` и определяют свою логику обновления при получении уведомления. Затем мы создаем класс `Subject`, который содержит вектор наблюдателей и методы для регистрации, удаления и уведомления наблюдателей. В `main` функции мы создаем субъект, наблюдателей, регистрируем их, уведомляем и открепляем одного из наблюдателей.

При запуске программы выведется следующий результат:

```
ConcreteObserverA: Received notification.
ConcreteObserverB: Received notification.
ConcreteObserverB: Received notification.
```

Как видно из вывода, наблюдатели успешно получают уведомления при изменении состояния субъекта.

# Паттерн "Стратегия"

Описание паттерна:
Паттерн "Стратегия" позволяет определить семейство алгоритмов, инкапсулировать каждый из них и сделать их взаимозаменяемыми. Таким образом, можно изменять используемый алгоритм независимо от клиентского кода, который его использует. Паттерн "Стратегия" способствует легкому добавлению новых алгоритмов и обеспечивает гибкость и расширяемость системы.

Примеры использования в C++:
Паттерн "Стратегия" может быть использован в различных ситуациях, когда необходимо выбирать алгоритм на основе контекста или когда требуется гибкое изменение поведения объекта. Некоторые примеры использования паттерна "Стратегия" в C++ включают:

1. Сортировка: В алгоритмах сортировки можно применять паттерн "Стратегия", где каждый алгоритм сортировки реализуется в отдельном классе-стратегии. Клиентский код может выбирать и задавать конкретную стратегию сортировки в зависимости от требований.

2. Кэширование: В системах кэширования можно использовать паттерн "Стратегия", чтобы различать разные алгоритмы кэширования, такие как Least Recently Used (LRU), First-In-First-Out (FIFO) и другие. Клиентский код может выбирать подходящую стратегию кэширования в зависимости от контекста или требований.

3. Валидация данных: В системах валидации данных можно применять паттерн "Стратегия", чтобы различать разные алгоритмы валидации. Например, можно иметь разные стратегии для валидации электронной почты, телефонного номера, пароля и т.д.

Реализация паттерна "Стратегия":
В C++ паттерн "Стратегия" может быть реализован с использованием полиморфизма и наследования. Основные компоненты реализации включают:

1. Интерфейс Strategy (Стратегия): Определяет общие методы, которые должны быть реализованы конкретными стратегиями.

2. Классы ConcreteStrategy (Конкретные стратегии): Реализуют интерфейс Strategy и определяют конкретные алгоритмы.

3. Класс Context (Контекст): Использует стр

атегии для выполнения определенных операций. Контекст содержит ссылку на объект стратегии и вызывает его методы в соответствии с текущим контекстом.

Вот пример реализации паттерна "Стратегия" на C++14:

```cpp
#include <iostream>

// Интерфейс Strategy
class Strategy {
public:
    virtual void execute() const = 0;
};

// Классы ConcreteStrategy
class ConcreteStrategyA : public Strategy {
public:
    void execute() const override {
        std::cout << "Executing ConcreteStrategyA.\n";
    }
};

class ConcreteStrategyB : public Strategy {
public:
    void execute() const override {
        std::cout << "Executing ConcreteStrategyB.\n";
    }
};

// Класс Context
class Context {
private:
    Strategy* strategy;

public:
    Context(Strategy* strategy) : strategy(strategy) {}

    void setStrategy(Strategy* strategy) {
        this->strategy = strategy;
    }

    void executeStrategy() const {
        strategy->execute();
    }
};

int main() {
    // Создание стратегий
    ConcreteStrategyA strategyA;
    ConcreteStrategyB strategyB;

    // Создание контекста с начальной стратегией
    Context context(&strategyA);

    // Выполнение стратегии A
    context.executeStrategy();

    // Изменение стратегии на B
    context.setStrategy(&strategyB);

    // Выполнение стратегии B
    context.executeStrategy();

    return 0;
}
```

В данном примере мы создаем интерфейс `Strategy`, который определяет метод `execute()` для выполнения алгоритма. Затем мы создаем классы `ConcreteStrategyA` и `ConcreteStrategyB`, которые реализуют интерфейс `Strategy` и определяют свои конкретные алгоритмы. Класс `Context` содержит ссылку на объект стратегии и вызывает его метод `execute()` в методе `executeStrategy()`. В `main` функции мы создаем стратегии, создаем контекст с начальной стратегией, выполняем стратегию A, затем изменяем стратегию на B и выполняем стратегию B.

При запуске программы выведется следующий результат:

```
Executing ConcreteStrategyA.
Executing ConcreteStrategyB.
```

Как видно из вывода, стратегии успешно выполняются и можно легко изменять используемую стратегию в контексте.

# Паттерн "Команда"

Описание паттерна:
Паттерн "Команда" позволяет инкапсулировать запросы в отдельные объекты, делая их независимыми от отправителей и получателей. Он превращает запросы в объекты, что позволяет параметризовать клиентские объекты с различными запросами, организовывать очереди или регистрировать историю запросов. В результате паттерн "Команда" обеспечивает гибкость и расширяемость системы.

Примеры использования в C++:
Паттерн "Команда" может быть использован в различных ситуациях, когда требуется отделить инициатора запроса от получателя, а также когда нужно обеспечить отмену операций или восстановление состояния. Некоторые примеры использования паттерна "Команда" в C++ включают:

1. Обработка пользовательских команд: В интерактивных приложениях паттерн "Команда" может быть использован для обработки пользовательских команд. Каждая команда представлена отдельным объектом команды, который может быть выполнен, отменен или повторен.

2. Управление устройствами: В системах управления устройствами паттерн "Команда" может использоваться для абстрагирования команд, которые выполняются на устройствах. Например, можно иметь команды для включения/выключения света, регулировки громкости или управления роботом.

3. Транзакционные операции: В базах данных паттерн "Команда" может быть использован для реализации транзакций, где каждая команда представляет отдельную операцию, которая может быть зафиксирована или отменена.

Реализация паттерна "Команда":
В C++ паттерн "Команда" может быть реализован с использованием классов и интерфейсов. Основные компоненты реализации включают:

1. Интерфейс Command (Команда): Определяет методы, которые должны быть реализованы конкретными командами, например, методы `execute()`, `undo()` и `redo()`.

2. Классы ConcreteCommand (Конкретные команды): Реализуют интерфейс Command и определяют конкретные операции, которые могут быть выполнены, отменены или повторены. Конкретные команды могут содержать ссылки на объекты-получатели, которые выполняют фактическую работу.

3. Класс Invoker (Инициатор): Инициирует выполнение команд, может иметь ссылку на объект команды или хранить команду в очереди.

4. Класс Receiver (Получатель): Выполняет фактическую работу, связанную с выполнением команд.

Вот пример реализации паттерна "Команда" на C++14:

```cpp
#include <iostream>
#include <vector>

// Интерфейс Command
class Command {
public:
    virtual void execute() = 0;
    virtual void undo() = 0;
    virtual void redo() = 0;
};

// Класс ConcreteCommandA
class ConcreteCommandA : public Command {
private:
    // Ссылка на объект-получатель
    Receiver& receiver;

public:
    ConcreteCommandA(Receiver& receiver) : receiver(receiver) {}

    void execute() override {
        receiver.performActionA();
    }

    void undo() override {
        receiver.undoActionA();
    }

    void redo() override {
        execute();
    }
};

// Класс ConcreteCommandB
class ConcreteCommandB : public Command {
private:
    // Ссылка на объект-получатель
    Receiver& receiver;

public:
    ConcreteCommandB(Receiver& receiver) : receiver(receiver) {}

    void execute() override {
        receiver.performActionB();
    }

    void undo() override {
        receiver.undoActionB();
    }

    void redo() override {
        execute();
    }
};

// Класс Receiver
class Receiver {
public:
    void performActionA() {
        std::cout << "Receiver: Performing action A.\n";
    }

    void undoActionA() {
        std::cout << "Receiver: Undoing action A.\n";
    }

    void performActionB() {
        std::cout << "Receiver: Performing action B.\n";
    }

    void undoActionB() {
        std::cout << "Receiver: Undoing action B.\n";
    }
};

// Класс Invoker
class Invoker {
private:
    std::vector<Command*> commands;

public:
    void addCommand(Command* command) {
        commands.push_back(command);
    }

    void executeCommands() {
        for (Command* command : commands) {
            command->execute();
        }
        commands.clear();
    }
};

int main() {
    // Создание объекта-получателя
    Receiver receiver;

    // Создание команд
    ConcreteCommandA commandA(receiver);
    ConcreteCommandB commandB(receiver);

    // Создание объекта инициатора
    Invoker invoker;

    // Добавление команд в инициатора
    invoker.addCommand(&commandA);
    invoker.addCommand(&commandB);

    // Выполнение команд
    invoker.executeCommands();

    return 0;
}
```

В данном примере мы создаем интерфейс `Command`, который определяет методы `execute()`, `undo()` и `redo()` для выполнения, отмены и повтора команд. Затем мы создаем классы `ConcreteCommandA` и `ConcreteCommandB`, которые реализуют интерфейс `Command` и определяют свои конкретные операции. Класс `Receiver` выполняет фактическую работу, связанную с выполнением команд. Класс

 `Invoker` содержит в себе список команд и выполняет их вызов методом `executeCommands()`. В `main` функции мы создаем объект-получатель, создаем команды, добавляем команды в инициатор и выполняем команды.

При запуске программы выведется следующий результат:

```
Receiver: Performing action A.
Receiver: Performing action B.
```

Как видно из вывода, команды успешно выполняются, и можно легко добавлять новые команды или отменять выполненные команды.

# Паттерн "Состояние"

Описание паттерна:
Паттерн "Состояние" позволяет объекту изменять свое поведение в зависимости от внутреннего состояния. Он выделяет отдельные состояния в виде отдельных классов, которые реализуют общий интерфейс. Объект, имеющий состояние, делегирует выполнение операций соответствующему состоянию. Паттерн "Состояние" позволяет достичь гибкости и расширяемости, позволяя объектам изменять свое поведение во время выполнения программы.

Примеры использования в C++:
Паттерн "Состояние" может быть использован в различных ситуациях, когда объекту необходимо изменять свое поведение в зависимости от внутреннего состояния. Некоторые примеры использования паттерна "Состояние" в C++ включают:

1. Автоматы состояний: В системах, где объекту нужно пройти через различные состояния, паттерн "Состояние" может быть использован для реализации автоматов состояний. Каждое состояние представлено отдельным классом, и объект делегирует выполнение операций текущему состоянию.

2. Расчетные системы: В финансовых расчетных системах паттерн "Состояние" может быть использован для управления поведением объекта в зависимости от текущего состояния. Например, объект может находиться в состоянии "открытого счета", "закрытого счета" или "блокировки счета", и его поведение будет изменяться соответствующим образом в каждом состоянии.

3. Игровые движки: В игровых движках паттерн "Состояние" может быть использован для управления поведением игровых объектов в зависимости от их текущего состояния. Например, игровой персонаж может находиться в состояниях "ходьба", "бег", "атака" и т.д., и его действия будут зависеть от текущего состояния.

Реализация паттерна "Состояние":
В C++ паттерн "Состояние" может быть реализован с использованием классов и наследования. Основные компоненты реализации включают:

1. Интерфейс State (Состояние): Определяет методы, которые должны быть реализованы конкретными состояниями. Например, методы `

doAction()`, `handleInput()` и т.д.

2. Классы ConcreteState (Конкретные состояния): Реализуют интерфейс State и определяют конкретное поведение объекта в каждом состоянии. Каждый класс представляет отдельное состояние.

3. Класс Context (Контекст): Содержит ссылку на текущее состояние и делегирует вызовы методов текущему состоянию. Класс Context также может содержать дополнительную логику, связанную с управлением состояниями.

Вот пример реализации паттерна "Состояние" на C++:

```cpp
#include <iostream>

// Интерфейс State
class State {
public:
    virtual void doAction() = 0;
    virtual void handleInput() = 0;
};

// Класс ConcreteStateA
class ConcreteStateA : public State {
public:
    void doAction() override {
        std::cout << "ConcreteStateA: Doing action A.\n";
    }

    void handleInput() override {
        std::cout << "ConcreteStateA: Handling input in state A.\n";
    }
};

// Класс ConcreteStateB
class ConcreteStateB : public State {
public:
    void doAction() override {
        std::cout << "ConcreteStateB: Doing action B.\n";
    }

    void handleInput() override {
        std::cout << "ConcreteStateB: Handling input in state B.\n";
    }
};

// Класс Context
class Context {
private:
    State* currentState;

public:
    Context(State* initialState) : currentState(initialState) {}

    void setState(State* state) {
        currentState = state;
    }

    void doAction() {
        currentState->doAction();
    }

    void handleInput() {
        currentState->handleInput();
    }
};

int main() {
    // Создание состояний
    ConcreteStateA stateA;
    ConcreteStateB stateB;

    // Создание контекста и установка начального состояния
    Context context(&stateA);

    // Выполнение действий и обработка ввода
    context.doAction();
    context.handleInput();

    // Изменение состояния и повторное выполнение
    context.setState(&stateB);
    context.doAction();
    context.handleInput();

    return 0;
}
```

В данном примере мы создаем интерфейс `State`, который определяет методы `doAction()` и `handleInput()` для выполнения действий и обработки ввода в каждом состоянии. Затем мы создаем классы `ConcreteStateA` и `ConcreteStateB`, которые реализуют интерфейс `State` и определяют свое конкретное поведение. Класс `Context` содержит ссылку на текущее состояние и делегирует вызовы методов текущему состоянию. В `main` функции мы создаем состояния, создаем контекст и устанавливаем начальное состояние, выполняем действия и обрабатываем ввод. Затем мы изменяем состояние и повторно вып

олняем действия и обработку ввода.

При запуске программы выведется следующий результат:

```
ConcreteStateA: Doing action A.
ConcreteStateA: Handling input in state A.
ConcreteStateB: Doing action B.
ConcreteStateB: Handling input in state B.
```

Как видно из вывода, объект меняет свое поведение в зависимости от текущего состояния, и можно легко добавлять новые состояния или изменять поведение объекта во время выполнения программы.

# Паттерн "Посетитель" 

Описание паттерна:
Паттерн "Посетитель" позволяет добавлять новые операции к объектам без изменения их классов. Он позволяет разделить алгоритмы от структуры объектов, на которых они оперируют. Паттерн "Посетитель" определяет новый класс посетителя, который содержит методы для выполнения операций над объектами различных классов. Каждый класс-элемент имеет метод `accept()`, который принимает посетителя и делегирует ему вызов соответствующего метода.

Примеры использования в C++:
Паттерн "Посетитель" может быть использован в различных ситуациях, когда необходимо добавить новую операцию к объектам, не изменяя их классов. Некоторые примеры использования паттерна "Посетитель" в C++ включают:

1. Обработка элементов коллекции: Паттерн "Посетитель" может быть использован для обработки элементов коллекции различными способами. Каждый элемент коллекции может принимать посетителя и делегировать ему выполнение соответствующей операции.

2. Обход иерархии объектов: Паттерн "Посетитель" может быть использован для обхода иерархии объектов и выполнения операций над каждым объектом в зависимости от его типа. Каждый объект может принимать посетителя и вызывать соответствующий метод.

3. Расширение функциональности: Паттерн "Посетитель" может быть использован для добавления новой функциональности к классам без изменения их исходного кода. Посетитель может содержать новые методы для выполнения дополнительных операций.

Реализация паттерна "Посетитель":
В C++ паттерн "Посетитель" может быть реализован с использованием классов и наследования. Основные компоненты реализации включают:

1. Интерфейс Element (Элемент): Определяет метод `accept()`, который принимает посетителя.

2. Классы ConcreteElement (Конкретные элементы): Реализуют интерфейс Element и содержат дополнительные методы и свойства. Каждый класс представляет отдельный элемент.

3. Интерфейс Visitor (Посетитель): Определяет методы для выполнения операций над различными элементами.

4. Классы ConcreteVisitor (Конкретные посетители): Реализуют интерфейс Visitor и содержат реализации методов операций для каждого элемента.

Вот пример реализации паттерна "Посетитель" на C++:



```cpp
#include <iostream>

// Интерфейс Element
class Element {
public:
    virtual void accept(class Visitor& visitor) = 0;
};

// Класс ConcreteElementA
class ConcreteElementA : public Element {
public:
    void accept(Visitor& visitor) override;
    void operationA() {
        std::cout << "ConcreteElementA: Operation A\n";
    }
};

// Класс ConcreteElementB
class ConcreteElementB : public Element {
public:
    void accept(Visitor& visitor) override;
    void operationB() {
        std::cout << "ConcreteElementB: Operation B\n";
    }
};

// Интерфейс Visitor
class Visitor {
public:
    virtual void visit(ConcreteElementA& elementA) = 0;
    virtual void visit(ConcreteElementB& elementB) = 0;
};

// Класс ConcreteVisitor
class ConcreteVisitor : public Visitor {
public:
    void visit(ConcreteElementA& elementA) override {
        std::cout << "ConcreteVisitor: Visiting ConcreteElementA\n";
        elementA.operationA();
    }

    void visit(ConcreteElementB& elementB) override {
        std::cout << "ConcreteVisitor: Visiting ConcreteElementB\n";
        elementB.operationB();
    }
};

// Реализация метода accept для ConcreteElementA
void ConcreteElementA::accept(Visitor& visitor) {
    visitor.visit(*this);
}

// Реализация метода accept для ConcreteElementB
void ConcreteElementB::accept(Visitor& visitor) {
    visitor.visit(*this);
}

int main() {
    // Создание элементов
    ConcreteElementA elementA;
    ConcreteElementB elementB;

    // Создание посетителя
    ConcreteVisitor visitor;

    // Вызов метода accept для каждого элемента
    elementA.accept(visitor);
    elementB.accept(visitor);

    return 0;
}
```

В данном примере мы создаем интерфейс `Element`, который определяет метод `accept()`, который принимает посетителя. Затем мы создаем классы `ConcreteElementA` и `ConcreteElementB`, которые реализуют интерфейс `Element` и имеют свои собственные методы и свойства. Класс `Visitor` определяет методы `visit()`, которые реализуют операции над элементами. Класс `ConcreteVisitor` наследуется от `Visitor` и реализует методы `visit()` для каждого элемента. В `main` функции мы создаем элементы и посетителя, затем вызываем метод `accept()` для каждого элемента, передавая посетителя. Каждый элемент вызывает соответствующий метод `visit()` у посетителя, который выполняет операцию над элементом.

При запуске программы выведется следующий результат:

```
ConcreteVisitor: Visiting ConcreteElementA
ConcreteElementA: Operation A
ConcreteVisitor: Visiting ConcreteElementB
ConcreteElementB: Operation B
```

Как видно из вывода, объект посетителя посещает каждый элемент и выполняет соответствующую операцию над ним. Паттерн "Посетитель" позволяет добавлять новые операции, не изменяя классы элементов, и обеспечивает легкое расширение функциональности.

Вот краткий обзор некоторых других поведенческих паттернов, которые не были рассмотрены в этой лекции:

1. Паттерн "Итератор" (Iterator): Предоставляет способ последовательного доступа ко всем элементам объекта-агрегата без раскрытия его внутренней структуры.

2. Паттерн "Цепочка обязанностей" (Chain of Responsibility): Позволяет передавать запросы последовательно по цепочке потенциальных обработчиков, пока один из них не обработает запрос.

3. Паттерн "Посредник" (Mediator): Определяет объект, который инкапсулирует взаимодействие между набором объектов. Посредник обеспечивает слабую связь между объектами, управляет их взаимодействием и помогает избежать зависимостей между ними.

4. Паттерн "Хранитель" (Memento): Позволяет сохранять и восстанавливать внутреннее состояние объекта без нарушения инкапсуляции. Хранитель фиксирует и хранит состояние объекта, позволяя восстановить его в будущем.

5. Паттерн "Интерпретатор" (Interpreter): Определяет представление грамматического правила для заданного языка и интерпретирует предложения на этом языке.

6. Паттерн "Итератор посетителя" (Visitor Iterator): Комбинирует итератор и посетителя, чтобы обеспечить последовательный доступ и обработку элементов коллекции.

7. Паттерн "Шаблонный метод" (Template Method): Определяет основу алгоритма в суперклассе, позволяя подклассам переопределить некоторые шаги алгоритма, но сохраняя его общую структуру.

8. Паттерн "Инверсия зависимостей" (Dependency Inversion): Предлагает, чтобы зависимости не строились на основе конкретных классов, а на основе абстракций, чтобы классы были связаны через интерфейсы или абстрактные классы.

9. Паттерн "Событие" (Event): Определяет способ уведомления об изменениях или событиях, происходящих в системе. Это позволяет объектам регистрировать свои обработчики событий и реагировать на них.

10. Паттерн "Null-объект" (Null Object): Предлагает использовать специальный объект, который представляет отсутствие значения или некую нейтральную реализацию интерфейса, чтобы избежать проверки на null и обработать такие ситуации без ошибок.

Каждый из этих паттернов решает определенные проблемы и предлагает свои подходы к проектированию программных систем. Изучение и применение этих паттернов может помочь вам создавать более гибкие, расширяемые и удобные в поддержке приложения.

# В заключение лекции, давайте повторим основные идеи, обсужденные в этой лекции, и обсудим значимость поведенческих паттернов в разработке на C++.

В ходе этой лекции мы изучили поведенческие паттерны - это категория паттернов проектирования, которые решают задачи, связанные с организацией взаимодействия между объектами и управлением их поведением. Поведенческие паттерны позволяют достичь гибкости и расширяемости кода, улучшить его читаемость и облегчить поддержку.

Мы рассмотрели несколько популярных поведенческих паттернов, таких как "Наблюдатель", "Стратегия", "Команда", "Состояние" и "Посетитель". Каждый из этих паттернов имеет свою уникальную концепцию и применяется в определенных ситуациях.

Поведенческие паттерны играют важную роль в разработке на C++. Они помогают упростить проектирование, разделить обязанности между классами, сделать код более гибким и поддерживаемым. Они также способствуют повышению повторного использования кода и улучшению расширяемости системы.

Ознакомление с поведенческими паттернами и их применение в разработке на C++ помогут вам стать более эффективным программистом и создавать высококачественное программное обеспечение.


# Паттерн "Цепочка обязанностей" (Chain of Responsibility) позволяет создать цепочку объектов-обработчиков, каждый из которых имеет возможность обработать запрос, либо передать его следующему обработчику в цепочке. Таким образом, запрос проходит по цепочке, пока не будет обработан или пока не достигнет конца цепи.

Описание паттерна:
- Определяет абстрактный базовый класс (или интерфейс), который представляет обработчик запроса и содержит ссылку на следующий обработчик в цепочке.
- Каждый конкретный обработчик реализует метод обработки запроса и определяет, может ли он сам обработать запрос или должен передать его следующему обработчику в цепочке.
- Клиент создает цепочку обработчиков и отправляет запрос на обработку первому обработчику в цепочке.

Примеры использования в C++:
1. Обработка запросов в веб-фреймворке: Веб-фреймворк может использовать цепочку обработчиков для обработки запросов от клиентов. Каждый обработчик может проверять различные аспекты запроса, такие как аутентификация, авторизация, валидация и т.д. Если один обработчик не может обработать запрос, он передает его следующему обработчику в цепочке.

2. Логирование с разными уровнями детализации: Цепочка обработчиков может быть использована для логирования с разными уровнями детализации. Например, обработчик может проверять, соответствует ли сообщение определенному уровню логирования, и если да, то обрабатывать его. Если сообщение не соответствует текущему уровню, оно передается следующему обработчику в цепочке.

Реализация паттерна "Цепочка обязанностей":
```cpp
#include <iostream>

// Базовый класс обработчика
class Handler {
public:
    Handler* next_; // Ссылка на следующий обработчик в цепочке

    Handler() : next_(nullptr) {}

    // Установка следующего обработчика
    void setNext(Handler* handler) {
        next_ = handler;
    }

    // Обработка запроса
    virtual void handleRequest(int request) = 0;
};

// Конкретный обработчик 1
class ConcreteHandler1 : public Handler {
public:
    void handleRequest(int request) override {
        if (request >= 0 && request < 10) {
            std::cout << "ConcreteHandler1: Обработка запроса " << request << std::endl;
        } else if (next_ != nullptr) {
            next_->handleRequest(request);
        }
    }
};

//

 Конкретный обработчик 2
class ConcreteHandler2 : public Handler {
public:
    void handleRequest(int request) override {
        if (request >= 10 && request < 20) {
            std::cout << "ConcreteHandler2: Обработка запроса " << request << std::endl;
        } else if (next_ != nullptr) {
            next_->handleRequest(request);
        }
    }
};

// Конкретный обработчик 3
class ConcreteHandler3 : public Handler {
public:
    void handleRequest(int request) override {
        if (request >= 20 && request < 30) {
            std::cout << "ConcreteHandler3: Обработка запроса " << request << std::endl;
        } else if (next_ != nullptr) {
            next_->handleRequest(request);
        }
    }
};

int main() {
    // Создание обработчиков
    Handler* handler1 = new ConcreteHandler1();
    Handler* handler2 = new ConcreteHandler2();
    Handler* handler3 = new ConcreteHandler3();

    // Установка цепочки обработчиков
    handler1->setNext(handler2);
    handler2->setNext(handler3);

    // Обработка запросов
    handler1->handleRequest(5);
    handler1->handleRequest(15);
    handler1->handleRequest(25);

    // Освобождение памяти
    delete handler1;
    delete handler2;
    delete handler3;

    return 0;
}
```

В этом примере у нас есть три конкретных обработчика: ConcreteHandler1, ConcreteHandler2 и ConcreteHandler3. Каждый обработчик проверяет условие для обработки запроса и передает его следующему обработчику в цепочке, если условие не выполняется.

Это основа реализации паттерна "Цепочка обязанностей" в C++. Вы можете создавать более сложные цепочки и добавлять новые обработчики в любое время без изменения клиентского кода.

# VIII. Паттерн "Посредник"

Описание паттерна:
Паттерн "Посредник" (Mediator) используется для упрощения коммуникации и взаимодействия между объектами. Он представляет объект-посредник, который централизует коммуникацию между другими объектами, управляет и координирует их взаимодействие. Вместо того чтобы объекты общались напрямую, они общаются через посредника.

Примеры использования в C++:
1. Графический интерфейс: В графическом интерфейсе посредник может использоваться для управления взаимодействием между различными элементами интерфейса, например, кнопками, полями ввода и т.д. Когда один элемент изменяется, он сообщает об этом посреднику, который в свою очередь обновляет остальные элементы в соответствии с новым состоянием.

2. Торговая площадка: На торговой площадке посредник может использоваться для связи между продавцами и покупателями. Когда продавец размещает товар, посредник оповещает всех потенциальных покупателей. Покупатели могут общаться с продавцом через посредника, который обрабатывает все запросы и предлагает решения.

Реализация паттерна "Посредник":
```cpp
#include <iostream>
#include <string>
#include <vector>

// Базовый класс посредника
class Mediator {
public:
    virtual void sendMessage(const std::string& message, class Colleague* colleague) = 0;
};

// Конкретный посредник
class ConcreteMediator : public Mediator {
private:
    std::vector<class Colleague*> colleagues_;

public:
    void addColleague(class Colleague* colleague) {
        colleagues_.push_back(colleague);
    }

    void sendMessage(const std::string& message, class Colleague* colleague) override {
        for (auto& col : colleagues_) {
            if (col != colleague) {
                col->receiveMessage(message);
            }
        }
    }
};

// Базовый класс коллеги
class Colleague {
protected:
    Mediator* mediator_;

public:
    explicit Colleague(Mediator* mediator) : mediator_(mediator) {}

    virtual void sendMessage(const std::string& message) = 0;

    virtual void receiveMessage(const std::string& message) = 0;
};

// Конкретный коллега
class ConcreteColleague : public Colleague {
public:
    explicit ConcreteColleague(Mediator* mediator) : Colleague(mediator) {}

    void sendMessage(const std::string& message) override {
        mediator_->sendMessage(message, this);
    }

    void receiveMessage(const std::string& message) override {
        std::cout << "Коллега получил сообщение

: " << message << std::endl;
    }
};

int main() {
    ConcreteMediator mediator;

    ConcreteColleague colleague1(&mediator);
    ConcreteColleague colleague2(&mediator);
    ConcreteColleague colleague3(&mediator);

    mediator.addColleague(&colleague1);
    mediator.addColleague(&colleague2);
    mediator.addColleague(&colleague3);

    colleague1.sendMessage("Привет!");
    colleague2.sendMessage("Как дела?");
    colleague3.sendMessage("Всем привет!");

    return 0;
}
```

В этом примере у нас есть класс посредника ConcreteMediator и классы коллег Colleague. Каждый коллег имеет ссылку на посредника и может отправлять ему сообщения. Посредник в свою очередь перенаправляет сообщения другим коллегам, и они получают эти сообщения через метод receiveMessage.

# IX. Паттерн "Посетитель"

Описание паттерна:
Паттерн "Посетитель" (Visitor) позволяет добавлять новые операции к объектам без изменения самих объектов. Он представляет собой способ отделения алгоритмов от структур данных, по которым эти алгоритмы работают. Посетитель позволяет добавлять новые операции, не изменяя классы, над которыми операции выполняются.

Примеры использования в C++:
1. Обработка элементов коллекции: Если у вас есть коллекция объектов разных типов, и вы хотите применить к каждому объекту разные операции, вы можете использовать паттерн "Посетитель". Каждый тип объекта может иметь свою собственную реализацию метода accept, который принимает посетителя и вызывает соответствующий метод в посетителе.

2. Обход дерева: Если у вас есть иерархия объектов, например, дерево, и вы хотите выполнить определенные операции на каждом узле дерева, вы можете использовать паттерн "Посетитель". Каждый узел дерева может иметь свою реализацию метода accept, который принимает посетителя и вызывает соответствующий метод в посетителе.

Реализация паттерна "Посетитель":
```cpp
#include <iostream>
#include <vector>

// Предварительное объявление класса Visitor
class Visitor;

// Абстрактный базовый класс элемента
class Element {
public:
    virtual void accept(Visitor* visitor) = 0;
};

// Конкретный элемент 1
class ConcreteElement1 : public Element {
public:
    void accept(Visitor* visitor) override;

    void operation1() {
        std::cout << "Выполнение операции 1 для ConcreteElement1" << std::endl;
    }
};

// Конкретный элемент 2
class ConcreteElement2 :

 public Element {
public:
    void accept(Visitor* visitor) override;

    void operation2() {
        std::cout << "Выполнение операции 2 для ConcreteElement2" << std::endl;
    }
};

// Абстрактный базовый класс посетителя
class Visitor {
public:
    virtual void visit(ConcreteElement1* element) = 0;
    virtual void visit(ConcreteElement2* element) = 0;
};

// Конкретный посетитель
class ConcreteVisitor : public Visitor {
public:
    void visit(ConcreteElement1* element) override {
        element->operation1();
    }

    void visit(ConcreteElement2* element) override {
        element->operation2();
    }
};

// Реализация метода accept для ConcreteElement1
void ConcreteElement1::accept(Visitor* visitor) {
    visitor->visit(this);
}

// Реализация метода accept для ConcreteElement2
void ConcreteElement2::accept(Visitor* visitor) {
    visitor->visit(this);
}

int main() {
    ConcreteElement1 element1;
    ConcreteElement2 element2;

    ConcreteVisitor visitor;

    // Применение посетителя к элементам
    element1.accept(&visitor);
    element2.accept(&visitor);

    return 0;
}
```

В этом примере у нас есть классы элементов Element, конкретные классы ConcreteElement1 и ConcreteElement2, класс посетителя Visitor и конкретный посетитель ConcreteVisitor. Каждый элемент имеет метод accept, который принимает посетителя и вызывает соответствующий метод в посетителе. Посетитель в свою очередь выполняет операции над элементами.